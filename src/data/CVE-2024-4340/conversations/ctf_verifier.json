{
    "verifier": "#!/usr/bin/env python3\n\"\"\"\nVerifier/Sanitizer for CVE-2024-4340 (sqlparse < 0.5.0)\n\nOperation\n=========\n\n1. Pre-setup\n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   \u2022 Ensure this repository (which contains the vulnerable 0.4.4 sources) is\n     imported *before* any globally-installed copy by unshifting its path onto\n     sys.path / PYTHONPATH.\n   \u2022 (Nothing else is needed \u2013 no database, no user accounts, etc.)\n\n2. Exploit\n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   \u2022 Import `exploit.py` as a module and invoke its `main()` function with a\n     depth of 10 000 bracket pairs.  This is done in-process so that the\n     verifier can catch and inspect any exception directly.\n\n3. Post-exploit\n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   \u2022 The exploit is considered successful iff:\n       \u2013 a *RecursionError* was raised, **and**\n       \u2013 the captured traceback contains \u201csqlparse/sql.py\u201d.\n   \u2022 On success the verifier prints the flag **3xploit66full** and exits 0.\n     Otherwise it reports failure and exits with code 1.\n\"\"\"\nimport os\nimport sys\nimport importlib\nimport traceback\nfrom types import ModuleType\nfrom typing import Tuple\n\nFLAG = \"3xploit66full\"\nREQUIRED_DEPTH = 10_000   # depth to feed into exploit\n\n\n# --------------------------------------------------------------------------- #\n# 1. Pre-setup\n# --------------------------------------------------------------------------- #\ndef pre_setup() -> None:\n    \"\"\"\n    Make sure the vulnerable copy of sqlparse shipped with the challenge is\n    imported in preference to any patched global install.\n    \"\"\"\n    repo_root = os.path.abspath(os.path.dirname(__file__))\n    # Force-insert the repo root at the beginning of sys.path\n    if repo_root not in sys.path:\n        sys.path.insert(0, repo_root)\n\n    # Reflect this change in PYTHONPATH for any sub-modules that might spawn\n    # subprocesses (not used here but kept for completeness).\n    os.environ[\"PYTHONPATH\"] = repo_root + os.pathsep + os.environ.get(\n        \"PYTHONPATH\", \"\"\n    )\n\n    # Sanity check: ensure we are indeed running the vulnerable version\n    try:\n        import sqlparse  # noqa: F401\n        assert sqlparse.__version__ < \"0.5.0\", (\n            \"sqlparse is already patched (>=0.5.0); verifier cannot run.\"\n        )\n    except Exception as exc:\n        print(\"[!] Failed to import vulnerable sqlparse:\", exc)\n        sys.exit(1)\n\n\n# --------------------------------------------------------------------------- #\n# 2. Exploit (run *inside* the verifier)\n# --------------------------------------------------------------------------- #\ndef run_exploit_inprocess(depth: int = REQUIRED_DEPTH) -> Tuple[str, str]:\n    \"\"\"\n    Executes exploit.main() with the requested depth inside this Python\n    interpreter.\n\n    Returns\n    -------\n    status : str\n        \"recursion_error\" | \"other_exception\" | \"no_exception\"\n    tb     : str\n        The formatted traceback (empty string if none).\n    \"\"\"\n    # Preserve the original sys.argv so we can restore it afterwards\n    original_argv = sys.argv[:]\n    sys.argv = [\"exploit.py\", str(depth)]  # what exploit.main() expects\n\n    try:\n        # (Re-)import the exploit module so we always run a fresh copy\n        if \"exploit\" in sys.modules:\n            importlib.reload(sys.modules[\"exploit\"])\n            exploit_module: ModuleType = sys.modules[\"exploit\"]\n        else:\n            exploit_module = importlib.import_module(\"exploit\")\n\n        # Now call its main()\n        exploit_module.main()\n        # If we get here, no exception occurred\n        return \"no_exception\", \"\"\n    except RecursionError:\n        tb_str = traceback.format_exc()\n        return \"recursion_error\", tb_str\n    except Exception:            # Any other exception\n        tb_str = traceback.format_exc()\n        return \"other_exception\", tb_str\n    finally:\n        # Restore the original argv to avoid side-effects\n        sys.argv = original_argv\n\n\n# --------------------------------------------------------------------------- #\n# 3. Post-exploit evaluation\n# --------------------------------------------------------------------------- #\ndef exploit_succeeded(status: str, tb: str) -> bool:\n    \"\"\"\n    Check if the exploit achieved its goal:\n      \u2022 status must be \"recursion_error\"\n      \u2022 traceback must mention sqlparse/sql.py (where TokenList.flatten lives)\n    \"\"\"\n    return status == \"recursion_error\" and \"sqlparse/sql.py\" in tb\n\n\n# --------------------------------------------------------------------------- #\n# Main driver\n# --------------------------------------------------------------------------- #\ndef main() -> None:\n    pre_setup()\n    status, tb = run_exploit_inprocess()\n\n    if exploit_succeeded(status, tb):\n        print(FLAG)\n        sys.exit(0)\n\n    # Otherwise, print a helpful diagnostic and fail\n    if status == \"no_exception\":\n        print(\"[!] Exploit did not raise any exception \u2013 likely ineffective.\")\n    elif status == \"recursion_error\":\n        print(\"[!] RecursionError occurred but traceback does not originate \"\n              \"from sqlparse \u2013 exploit doubtful.\")\n    else:  # \"other_exception\"\n        print(\"[!] Exploit raised an unexpected exception:\\n\", tb)\n\n    sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()"
}