{
    "CVE-2025-32389": {
        "cwe": [
            {
                "id": "CWE-89",
                "value": "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
            }
        ],
        "description": "NamelessMC is a free, easy to use & powerful website software for Minecraft servers. Prior to version 2.1.4, NamelessMC is vulnerable to SQL injection by providing an unexpected square bracket GET parameter syntax. Square bracket GET parameter syntax refers to the structure `?param[0]=a&param[1]=b&param[2]=c` utilized by PHP, which is parsed by PHP as `$_GET['param']` being of type array. This issue has been patched in version 2.1.4.",
        "languages": [
            "PHP",
            "Smarty"
        ],
        "patch_commits": [
            {
                "content": "Merge commit from fork\n\nCo-authored-by: Sam <samerton@users.noreply.github.com>\n\nFilename: core/classes/Database/DB.php:\n```\n@@ -529,7 +529,7 @@\npublic static function makeWhere(array $clauses): array\n         $where_clauses = [];\n         foreach ($clauses as $clause) {\n             if (!is_array($clause)) {\n-                continue;\n+                throw new InvalidArgumentException('Where clause must be an array');\n             }\n \n             if (count($clause) !== count($clause, COUNT_RECURSIVE)) {\n```",
                "url": "https://github.com/NamelessMC/Nameless/commit/02c81c7c45b98fad1ebe3bc085efae18aec4566f"
            }
        ],
        "published_date": "2025-04-18T15:56:39.962Z",
        "sec_adv": [],
        "sw_version": "v2.1.3",
        "sw_version_wget": "https://github.com/NamelessMC/Nameless/archive/refs/tags/v2.1.3.zip"
    },
    "CVE-2025-46728": {
        "published_date": "2025-05-06T00:45:25.130Z",
        "patch_commits": [
            {
                "url": "https://github.com/yhirose/cpp-httplib/commit/7b752106ac42bd5b907793950d9125a0972c8e8e",
                "content": "Merge commit from fork\n\n* fix(parser): Limit line length in getline\n\nPrevents potential infinite loop and memory exhaustion in\nstream_line_reader::getline by enforcing max line length.\n\nSigned-off-by: Ville Vesilehto <ville@vesilehto.fi>\n\n* fix: increase default max line length to 32k\n\nLONG_QUERY_VALUE test is set at 25k.\n\nSigned-off-by: Ville Vesilehto <ville@vesilehto.fi>\n\n* test(client): expect read error with too long query\n\nAdds a test case (`TooLongQueryValue`) to verify client behavior\nwhen the request URI is excessively long, exceeding\n`CPPHTTPLIB_MAX_LINE_LENGTH`. In this scenario, the server is\nexpected to reset the connection.\n\nSigned-off-by: Ville Vesilehto <ville@vesilehto.fi>\n\n---------\n\nSigned-off-by: Ville Vesilehto <ville@vesilehto.fi>\n\nFilename: httplib.h:\n```\n@@ -145,6 +145,10 @@\n#define CPPHTTPLIB_LISTEN_BACKLOG 5\n #endif\n \n+#ifndef CPPHTTPLIB_MAX_LINE_LENGTH\n+#define CPPHTTPLIB_MAX_LINE_LENGTH 32768\n+#endif\n+\n /*\n  * Headers\n  */\n\n@@ -3067,6 +3071,11 @@\ninline bool stream_line_reader::getline() {\n #endif\n \n   for (size_t i = 0;; i++) {\n+    if (size() >= CPPHTTPLIB_MAX_LINE_LENGTH) {\n+      // Treat exceptionally long lines as an error to\n+      // prevent infinite loops/memory exhaustion\n+      return false;\n+    }\n     char byte;\n     auto n = strm_.read(&byte, 1);\n```\n\nFilename: test/test.cc:\n```\n@@ -43,6 +43,9 @@\nconst int PORT = 1234;\n const string LONG_QUERY_VALUE = string(25000, '@');\n const string LONG_QUERY_URL = \"/long-query-value?key=\" + LONG_QUERY_VALUE;\n \n+const string TOO_LONG_QUERY_VALUE = string(35000, '@');\n+const string TOO_LONG_QUERY_URL = \"/too-long-query-value?key=\" + TOO_LONG_QUERY_VALUE;\n+\n const std::string JSON_DATA = \"{\\\"hello\\\":\\\"world\\\"}\";\n \n const string LARGE_DATA = string(1024 * 1024 * 100, '@'); // 100MB\n\n@@ -2867,6 +2870,11 @@\nclass ServerTest : public ::testing::Test {\n                EXPECT_EQ(LONG_QUERY_URL, req.target);\n                EXPECT_EQ(LONG_QUERY_VALUE, req.get_param_value(\"key\"));\n              })\n+        .Get(\"/too-long-query-value\",\n+             [&](const Request &req, Response & /*res*/) {\n+               EXPECT_EQ(TOO_LONG_QUERY_URL, req.target);\n+               EXPECT_EQ(TOO_LONG_QUERY_VALUE, req.get_param_value(\"key\"));\n+             })\n         .Get(\"/array-param\",\n              [&](const Request &req, Response & /*res*/) {\n                EXPECT_EQ(3u, req.get_param_value_count(\"array\"));\n\n@@ -3655,6 +3663,13 @@\nTEST_F(ServerTest, LongQueryValue) {\n   EXPECT_EQ(StatusCode::UriTooLong_414, res->status);\n }\n \n+TEST_F(ServerTest, TooLongQueryValue) {\n+  auto res = cli_.Get(TOO_LONG_QUERY_URL.c_str());\n+\n+  ASSERT_FALSE(res);\n+  EXPECT_EQ(Error::Read, res.error());\n+}\n+\n TEST_F(ServerTest, TooLongHeader) {\n   Request req;\n   req.method = \"GET\";\n```"
            }
        ],
        "sw_version": "v0.20.0",
        "sw_version_wget": "https://github.com/yhirose/cpp-httplib/archive/refs/tags/v0.20.0.zip",
        "description": "cpp-httplib is a C++ header-only HTTP/HTTPS server and client library. Prior to version 0.20.1, the library fails to enforce configured size limits on incoming request bodies when `Transfer-Encoding: chunked` is used or when no `Content-Length` header is provided. A remote attacker can send a chunked request without the terminating zero-length chunk, causing uncontrolled memory allocation on the server. This leads to potential exhaustion of system memory and results in a server crash or unresponsiveness. Version 0.20.1 fixes the issue by enforcing limits during parsing. If the limit is exceeded at any point during reading, the connection is terminated immediately. A short-term workaround through a Reverse Proxy is available. If updating the library immediately is not feasible, deploy a reverse proxy (e.g., Nginx, HAProxy) in front of the `cpp-httplib` application. Configure the proxy to enforce maximum request body size limits, thereby stopping excessively large requests before they reach the vulnerable library code.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-400",
                "value": "CWE-400: Uncontrolled Resource Consumption"
            }
        ]
    },
    "CVE-2025-30208": {
        "published_date": "2025-03-24T17:03:40.728Z",
        "patch_commits": [
            {
                "url": "https://github.com/vitejs/vite/commit/315695e9d97cc6cfa7e6d9e0229fb50cdae3d9f4",
                "content": "fix: backport #19702, fs raw query with query separators (#19704)\n\nFilename: packages/vite/src/node/server/middlewares/transform.ts:\n```\n@@ -44,6 +44,7 @@\nimport { ensureServingAccess } from './static'\n const debugCache = createDebugger('vite:cache')\n \n const knownIgnoreList = new Set(['/', '/favicon.ico'])\n+const trailingQuerySeparatorsRE = /[?&]+$/\n \n export function transformMiddleware(\n   server: ViteDevServer,\n\n@@ -167,9 +168,19 @@\nexport function transformMiddleware(\n         }\n       }\n \n+      const urlWithoutTrailingQuerySeparators = url.replace(\n+        trailingQuerySeparatorsRE,\n+        '',\n+      )\n       if (\n-        (rawRE.test(url) || urlRE.test(url)) &&\n-        !ensureServingAccess(url, server, res, next)\n+        (rawRE.test(urlWithoutTrailingQuerySeparators) ||\n+          urlRE.test(urlWithoutTrailingQuerySeparators)) &&\n+        !ensureServingAccess(\n+          urlWithoutTrailingQuerySeparators,\n+          server,\n+          res,\n+          next,\n+        )\n       ) {\n         return\n       }\n```\n\nFilename: playground/fs-serve/__tests__/fs-serve.spec.ts:\n```\n@@ -96,6 +96,20 @@\ndescribe.runIf(isServe)('main', () => {\n     expect(await page.textContent('.unsafe-fs-fetch-raw-status')).toBe('403')\n   })\n \n+  test('unsafe fs fetch query 1', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n+  test('unsafe fs fetch query 2', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n   test('unsafe fs fetch with special characters (#8498)', async () => {\n     expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n     expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n```\n\nFilename: playground/fs-serve/root/src/index.html:\n```\n@@ -37,6 +37,10 @@\n<h2>Unsafe /@fs/ Fetch</h2>\n <pre class=\"unsafe-fs-fetch\"></pre>\n <pre class=\"unsafe-fs-fetch-raw-status\"></pre>\n <pre class=\"unsafe-fs-fetch-raw\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-status\"></pre>\n <pre class=\"unsafe-fs-fetch-8498\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-2-status\"></pre>\n\n@@ -209,6 +213,40 @@\n<h2>Denied</h2>\n       console.error(e)\n     })\n \n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw??',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query1-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query1', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw?&',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query2-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query2', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n   // outside root with special characters #8498\n   fetch(\n     joinUrlSegments(\n```"
            },
            {
                "url": "https://github.com/vitejs/vite/commit/80381c38d6f068b12e6e928cd3c616bd1d64803c",
                "content": "fix: fs raw query with query separators (#19702)\n\nFilename: packages/vite/src/node/server/middlewares/transform.ts:\n```\n@@ -43,6 +43,7 @@\nimport { ensureServingAccess } from './static'\n const debugCache = createDebugger('vite:cache')\n \n const knownIgnoreList = new Set(['/', '/favicon.ico'])\n+const trailingQuerySeparatorsRE = /[?&]+$/\n \n /**\n  * A middleware that short-circuits the middleware chain to serve cached transformed modules\n\n@@ -169,9 +170,19 @@\nexport function transformMiddleware(\n         warnAboutExplicitPublicPathInUrl(url)\n       }\n \n+      const urlWithoutTrailingQuerySeparators = url.replace(\n+        trailingQuerySeparatorsRE,\n+        '',\n+      )\n       if (\n-        (rawRE.test(url) || urlRE.test(url)) &&\n-        !ensureServingAccess(url, server, res, next)\n+        (rawRE.test(urlWithoutTrailingQuerySeparators) ||\n+          urlRE.test(urlWithoutTrailingQuerySeparators)) &&\n+        !ensureServingAccess(\n+          urlWithoutTrailingQuerySeparators,\n+          server,\n+          res,\n+          next,\n+        )\n       ) {\n         return\n       }\n```\n\nFilename: playground/fs-serve/__tests__/fs-serve.spec.ts:\n```\n@@ -96,6 +96,20 @@\ndescribe.runIf(isServe)('main', () => {\n     expect(await page.textContent('.unsafe-fs-fetch-raw-status')).toBe('403')\n   })\n \n+  test('unsafe fs fetch query 1', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n+  test('unsafe fs fetch query 2', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n   test('unsafe fs fetch with special characters (#8498)', async () => {\n     expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n     expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n```\n\nFilename: playground/fs-serve/root/src/index.html:\n```\n@@ -37,6 +37,10 @@\n<h2>Unsafe /@fs/ Fetch</h2>\n <pre class=\"unsafe-fs-fetch\"></pre>\n <pre class=\"unsafe-fs-fetch-raw-status\"></pre>\n <pre class=\"unsafe-fs-fetch-raw\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-status\"></pre>\n <pre class=\"unsafe-fs-fetch-8498\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-2-status\"></pre>\n\n@@ -209,6 +213,40 @@\n<h2>Denied</h2>\n       console.error(e)\n     })\n \n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw??',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query1-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query1', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw?&',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query2-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query2', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n   // outside root with special characters #8498\n   fetch(\n     joinUrlSegments(\n```"
            },
            {
                "url": "https://github.com/vitejs/vite/commit/807d7f06d33ab49c48a2a3501da3eea1906c0d41",
                "content": "fix: backport #19702, fs raw query with query separators (#19703)\n\nFilename: packages/vite/src/node/server/middlewares/transform.ts:\n```\n@@ -41,6 +41,7 @@\nimport { ensureServingAccess } from './static'\n const debugCache = createDebugger('vite:cache')\n \n const knownIgnoreList = new Set(['/', '/favicon.ico'])\n+const trailingQuerySeparatorsRE = /[?&]+$/\n \n /**\n  * A middleware that short-circuits the middleware chain to serve cached transformed modules\n\n@@ -163,9 +164,19 @@\nexport function transformMiddleware(\n         warnAboutExplicitPublicPathInUrl(url)\n       }\n \n+      const urlWithoutTrailingQuerySeparators = url.replace(\n+        trailingQuerySeparatorsRE,\n+        '',\n+      )\n       if (\n-        (rawRE.test(url) || urlRE.test(url)) &&\n-        !ensureServingAccess(url, server, res, next)\n+        (rawRE.test(urlWithoutTrailingQuerySeparators) ||\n+          urlRE.test(urlWithoutTrailingQuerySeparators)) &&\n+        !ensureServingAccess(\n+          urlWithoutTrailingQuerySeparators,\n+          server,\n+          res,\n+          next,\n+        )\n       ) {\n         return\n       }\n```\n\nFilename: playground/fs-serve/__tests__/fs-serve.spec.ts:\n```\n@@ -96,6 +96,20 @@\ndescribe.runIf(isServe)('main', () => {\n     expect(await page.textContent('.unsafe-fs-fetch-raw-status')).toBe('403')\n   })\n \n+  test('unsafe fs fetch query 1', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n+  test('unsafe fs fetch query 2', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n   test('unsafe fs fetch with special characters (#8498)', async () => {\n     expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n     expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n```\n\nFilename: playground/fs-serve/root/src/index.html:\n```\n@@ -37,6 +37,10 @@\n<h2>Unsafe /@fs/ Fetch</h2>\n <pre class=\"unsafe-fs-fetch\"></pre>\n <pre class=\"unsafe-fs-fetch-raw-status\"></pre>\n <pre class=\"unsafe-fs-fetch-raw\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-status\"></pre>\n <pre class=\"unsafe-fs-fetch-8498\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-2-status\"></pre>\n\n@@ -209,6 +213,40 @@\n<h2>Denied</h2>\n       console.error(e)\n     })\n \n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw??',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query1-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query1', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw?&',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query2-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query2', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n   // outside root with special characters #8498\n   fetch(\n     joinUrlSegments(\n```"
            },
            {
                "url": "https://github.com/vitejs/vite/commit/92ca12dc79118bf66f2b32ff81ed09e0d0bd07ca",
                "content": "fix: fs raw query with query separators (#19702)\n\nFilename: packages/vite/src/node/server/middlewares/transform.ts:\n```\n@@ -43,6 +43,7 @@\nimport { ensureServingAccess } from './static'\n const debugCache = createDebugger('vite:cache')\n \n const knownIgnoreList = new Set(['/', '/favicon.ico'])\n+const trailingQuerySeparatorsRE = /[?&]+$/\n \n /**\n  * A middleware that short-circuits the middleware chain to serve cached transformed modules\n\n@@ -169,9 +170,19 @@\nexport function transformMiddleware(\n         warnAboutExplicitPublicPathInUrl(url)\n       }\n \n+      const urlWithoutTrailingQuerySeparators = url.replace(\n+        trailingQuerySeparatorsRE,\n+        '',\n+      )\n       if (\n-        (rawRE.test(url) || urlRE.test(url)) &&\n-        !ensureServingAccess(url, server, res, next)\n+        (rawRE.test(urlWithoutTrailingQuerySeparators) ||\n+          urlRE.test(urlWithoutTrailingQuerySeparators)) &&\n+        !ensureServingAccess(\n+          urlWithoutTrailingQuerySeparators,\n+          server,\n+          res,\n+          next,\n+        )\n       ) {\n         return\n       }\n```\n\nFilename: playground/fs-serve/__tests__/fs-serve.spec.ts:\n```\n@@ -96,6 +96,20 @@\ndescribe.runIf(isServe)('main', () => {\n     expect(await page.textContent('.unsafe-fs-fetch-raw-status')).toBe('403')\n   })\n \n+  test('unsafe fs fetch query 1', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n+  test('unsafe fs fetch query 2', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n   test('unsafe fs fetch with special characters (#8498)', async () => {\n     expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n     expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n```\n\nFilename: playground/fs-serve/root/src/index.html:\n```\n@@ -37,6 +37,10 @@\n<h2>Unsafe /@fs/ Fetch</h2>\n <pre class=\"unsafe-fs-fetch\"></pre>\n <pre class=\"unsafe-fs-fetch-raw-status\"></pre>\n <pre class=\"unsafe-fs-fetch-raw\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-status\"></pre>\n <pre class=\"unsafe-fs-fetch-8498\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-2-status\"></pre>\n\n@@ -209,6 +213,40 @@\n<h2>Denied</h2>\n       console.error(e)\n     })\n \n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw??',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query1-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query1', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw?&',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query2-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query2', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n   // outside root with special characters #8498\n   fetch(\n     joinUrlSegments(\n```"
            },
            {
                "url": "https://github.com/vitejs/vite/commit/f234b5744d8b74c95535a7b82cc88ed2144263c1",
                "content": "fix: fs raw query with query separators (#19702)\n\nFilename: packages/vite/src/node/server/middlewares/transform.ts:\n```\n@@ -43,6 +43,7 @@\nimport { ensureServingAccess } from './static'\n const debugCache = createDebugger('vite:cache')\n \n const knownIgnoreList = new Set(['/', '/favicon.ico'])\n+const trailingQuerySeparatorsRE = /[?&]+$/\n \n /**\n  * A middleware that short-circuits the middleware chain to serve cached transformed modules\n\n@@ -169,9 +170,19 @@\nexport function transformMiddleware(\n         warnAboutExplicitPublicPathInUrl(url)\n       }\n \n+      const urlWithoutTrailingQuerySeparators = url.replace(\n+        trailingQuerySeparatorsRE,\n+        '',\n+      )\n       if (\n-        (rawRE.test(url) || urlRE.test(url)) &&\n-        !ensureServingAccess(url, server, res, next)\n+        (rawRE.test(urlWithoutTrailingQuerySeparators) ||\n+          urlRE.test(urlWithoutTrailingQuerySeparators)) &&\n+        !ensureServingAccess(\n+          urlWithoutTrailingQuerySeparators,\n+          server,\n+          res,\n+          next,\n+        )\n       ) {\n         return\n       }\n```\n\nFilename: playground/fs-serve/__tests__/fs-serve.spec.ts:\n```\n@@ -96,6 +96,20 @@\ndescribe.runIf(isServe)('main', () => {\n     expect(await page.textContent('.unsafe-fs-fetch-raw-status')).toBe('403')\n   })\n \n+  test('unsafe fs fetch query 1', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query1-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n+  test('unsafe fs fetch query 2', async () => {\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2')).toBe('')\n+    expect(await page.textContent('.unsafe-fs-fetch-raw-query2-status')).toBe(\n+      '403',\n+    )\n+  })\n+\n   test('unsafe fs fetch with special characters (#8498)', async () => {\n     expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n     expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n```\n\nFilename: playground/fs-serve/root/src/index.html:\n```\n@@ -37,6 +37,10 @@\n<h2>Unsafe /@fs/ Fetch</h2>\n <pre class=\"unsafe-fs-fetch\"></pre>\n <pre class=\"unsafe-fs-fetch-raw-status\"></pre>\n <pre class=\"unsafe-fs-fetch-raw\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query1\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2-status\"></pre>\n+<pre class=\"unsafe-fs-fetch-raw-query2\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-status\"></pre>\n <pre class=\"unsafe-fs-fetch-8498\"></pre>\n <pre class=\"unsafe-fs-fetch-8498-2-status\"></pre>\n\n@@ -209,6 +213,40 @@\n<h2>Denied</h2>\n       console.error(e)\n     })\n \n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw??',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query1-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query1', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n+  fetch(\n+    joinUrlSegments(\n+      base,\n+      joinUrlSegments('/@fs/', ROOT) + '/unsafe.json?import&raw?&',\n+    ),\n+  )\n+    .then((r) => {\n+      text('.unsafe-fs-fetch-raw-query2-status', r.status)\n+      return r.json()\n+    })\n+    .then((data) => {\n+      text('.unsafe-fs-fetch-raw-query2', JSON.stringify(data))\n+    })\n+    .catch((e) => {\n+      console.error(e)\n+    })\n+\n   // outside root with special characters #8498\n   fetch(\n     joinUrlSegments(\n```"
            }
        ],
        "sw_version": "v4.5.9",
        "sw_version_wget": "https://github.com/vitejs/vite/archive/refs/tags/v4.5.9.zip",
        "description": "Vite, a provider of frontend development tooling, has a vulnerability in versions prior to 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10. `@fs` denies access to files outside of Vite serving allow list. Adding `?raw??` or `?import&raw??` to the URL bypasses this limitation and returns the file content if it exists. This bypass exists because trailing separators such as `?` are removed in several places, but are not accounted for in query string regexes. The contents of arbitrary files can be returned to the browser. Only apps explicitly exposing the Vite dev server to the network (using `--host` or `server.host` config option) are affected. Versions 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10 fix the issue.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-200",
                "value": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
            },
            {
                "id": "CWE-284",
                "value": "CWE-284: Improper Access Control"
            }
        ]
    },
    "CVE-2025-27597": {
        "published_date": "2025-03-07T15:51:39.753Z",
        "patch_commits": [
            {
                "url": "https://github.com/intlify/vue-i18n/commit/4bb6eacda7fc2cde5687549afa0efb27ca40862a",
                "content": "fix: prototype pollution in `handleFlatJson`\n\nFilename: packages/vue-i18n-core/src/utils.ts:\n```\n@@ -69,6 +69,9 @@\nexport function handleFlatJson(obj: unknown): unknown {\n       let currentObj = obj\n       let hasStringValue = false\n       for (let i = 0; i < lastIndex; i++) {\n+        if (subKeys[i] === '__proto__') {\n+          throw new Error(`unsafe key: ${subKeys[i]}`)\n+        }\n         if (!(subKeys[i] in currentObj)) {\n           currentObj[subKeys[i]] = create()\n         }\n```\n\nFilename: packages/vue-i18n-core/test/utils.test.ts:\n```\n@@ -1,65 +1,80 @@\n// utils\n import * as shared from '@intlify/shared'\n+import { handleFlatJson } from '../src/utils'\n+import { I18nWarnCodes, getWarnMessage } from '../src/warnings'\n vi.mock('@intlify/shared', async () => {\n   const actual = await vi.importActual<object>('@intlify/shared')\n   return {\n     ...actual,\n     warn: vi.fn()\n   }\n })\n-import { handleFlatJson } from '../src/utils'\n-import { I18nWarnCodes, getWarnMessage } from '../src/warnings'\n \n-test('handleFlatJson', () => {\n-  const mockWarn = vi.spyOn(shared, 'warn')\n-  // eslint-disable-next-line @typescript-eslint/no-empty-function\n-  mockWarn.mockImplementation(() => {})\n+describe('handleFlatJson', () => {\n+  test('basic', () => {\n+    const mockWarn = vi.spyOn(shared, 'warn')\n+    // eslint-disable-next-line @typescript-eslint/no-empty-function\n+    mockWarn.mockImplementation(() => {})\n \n-  const obj = {\n-    a: { a1: 'a1.value' },\n-    'a.a2': 'a.a2.value',\n-    'b.x': {\n-      'b1.x': 'b1.x.value',\n-      'b2.x': ['b2.x.value0', 'b2.x.value1'],\n-      'b3.x': { 'b3.x': 'b3.x.value' }\n-    },\n-    c: {\n-      'animal.dog': 'Dog',\n-      animal: 'Animal'\n-    },\n-    d: {\n-      'animal.dog': 'Dog',\n-      animal: {}\n-    }\n-  }\n-  const expectObj = {\n-    a: {\n-      a1: 'a1.value',\n-      a2: 'a.a2.value'\n-    },\n-    b: {\n-      x: {\n-        b1: { x: 'b1.x.value' },\n-        b2: { x: ['b2.x.value0', 'b2.x.value1'] },\n-        b3: { x: { b3: { x: 'b3.x.value' } } }\n+    const obj = {\n+      a: { a1: 'a1.value' },\n+      'a.a2': 'a.a2.value',\n+      'b.x': {\n+        'b1.x': 'b1.x.value',\n+        'b2.x': ['b2.x.value0', 'b2.x.value1'],\n+        'b3.x': { 'b3.x': 'b3.x.value' }\n+      },\n+      c: {\n+        'animal.dog': 'Dog',\n+        animal: 'Animal'\n+      },\n+      d: {\n+        'animal.dog': 'Dog',\n+        animal: {}\n       }\n-    },\n-    c: {\n-      'animal.dog': 'Dog',\n-      animal: 'Animal'\n-    },\n-    d: {\n-      animal: {\n-        dog: 'Dog'\n+    }\n+    const expectObj = {\n+      a: {\n+        a1: 'a1.value',\n+        a2: 'a.a2.value'\n+      },\n+      b: {\n+        x: {\n+          b1: { x: 'b1.x.value' },\n+          b2: { x: ['b2.x.value0', 'b2.x.value1'] },\n+          b3: { x: { b3: { x: 'b3.x.value' } } }\n+        }\n+      },\n+      c: {\n+        'animal.dog': 'Dog',\n+        animal: 'Animal'\n+      },\n+      d: {\n+        animal: {\n+          dog: 'Dog'\n+        }\n       }\n     }\n-  }\n \n-  expect(handleFlatJson(obj)).toEqual(expectObj)\n-  expect(mockWarn).toHaveBeenCalled()\n-  expect(mockWarn.mock.calls[0][0]).toEqual(\n-    getWarnMessage(I18nWarnCodes.IGNORE_OBJ_FLATTEN, {\n-      key: 'animal'\n-    })\n-  )\n+    expect(handleFlatJson(obj)).toEqual(expectObj)\n+    expect(mockWarn).toHaveBeenCalled()\n+    expect(mockWarn.mock.calls[0][0]).toEqual(\n+      getWarnMessage(I18nWarnCodes.IGNORE_OBJ_FLATTEN, {\n+        key: 'animal'\n+      })\n+    )\n+  })\n+\n+  // security advisories\n+  // ref: https://github.com/intlify/vue-i18n/security/advisories/GHSA-p2ph-7g93-hw3m\n+  test('prototype pollution', () => {\n+    expect(() =>\n+      handleFlatJson({ '__proto__.pollutedKey': 'pollutedValue' })\n+    ).toThrow()\n+    // @ts-ignore -- test\n+    // eslint-disable-next-line no-proto\n+    expect({}.__proto__.pollutedKey).toBeUndefined()\n+    // @ts-ignore -- test\n+    expect(Object.prototype.pollutedKey).toBeUndefined()\n+  })\n })\n```"
            }
        ],
        "sw_version": "v9.1.0",
        "sw_version_wget": "https://github.com/intlify/vue-i18n/archive/refs/tags/v9.1.0.zip",
        "description": "Vue I18n is the internationalization plugin for Vue.js. @intlify/message-resolver and @intlify/vue-i18n-core are vulnerable to Prototype Pollution through the entry function: handleFlatJson. An attacker can supply a payload with Object.prototype setter to introduce or modify properties within the global prototype chain, causing denial of service (DoS) a the minimum consequence. Moreover, the consequences of this vulnerability can escalate to other injection-based attacks, depending on how the library integrates within the application. For instance, if the polluted property propagates to sensitive Node.js APIs (e.g., exec, eval), it could enable an attacker to execute arbitrary commands within the application's context.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-1321",
                "value": "CWE-1321: Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')"
            }
        ]
    },
    "CVE-2025-43855": {
        "published_date": "2025-04-24T13:58:30.536Z",
        "patch_commits": [
            {
                "url": "https://github.com/trpc/trpc/commit/9beb26c636d44852e0f407f3d7a82ad54df65b4d",
                "content": "Merge commit from fork\n\n* Don't throw already handled error\n\nThis error has already been handled so no need to re-throw. If we re-throw it will not be caught and will trigger an uncaught exception causing the entire server process to crash.\n\n* regression test\n\n* fewer promises\n\n* undef -> null\n\n---------\n\nCo-authored-by: Alexander Johansson <alexander@n1s.se>\n\nFilename: packages/server/src/adapters/fastify/fastifyTRPCPlugin.ts:\n```\n@@ -68,8 +68,8 @@\nexport function fastifyTRPCPlugin<TRouter extends AnyRouter>(\n       ...trpcOptions,\n     });\n \n-    fastify.get(prefix ?? '/', { websocket: true }, async (socket, req) => {\n-      await onConnection(socket, req.raw);\n+    fastify.get(prefix ?? '/', { websocket: true }, (socket, req) => {\n+      onConnection(socket, req.raw);\n       if (trpcOptions?.keepAlive?.enabled) {\n         const { pingMs, pongWaitMs } = trpcOptions.keepAlive;\n         handleKeepAlive(socket, pingMs, pongWaitMs);\n```\n\nFilename: packages/server/src/adapters/ws.ts:\n```\n@@ -34,6 +34,8 @@\nimport {\n   type MaybePromise,\n } from '../unstable-core-do-not-import';\n // eslint-disable-next-line no-restricted-imports\n+import type { Result } from '../unstable-core-do-not-import';\n+// eslint-disable-next-line no-restricted-imports\n import { iteratorResource } from '../unstable-core-do-not-import/stream/utils/asyncIterable';\n import { Unpromise } from '../vendor/unpromise';\n import { createURL, type NodeHTTPCreateContextFnOptions } from './node-http';\n\n@@ -98,14 +100,16 @@\nexport type WSSHandlerOptions<TRouter extends AnyRouter> =\n     dangerouslyDisablePong?: boolean;\n   };\n \n-const unsetContextPromiseSymbol = Symbol('unsetContextPromise');\n export function getWSConnectionHandler<TRouter extends AnyRouter>(\n   opts: WSSHandlerOptions<TRouter>,\n ) {\n   const { createContext, router } = opts;\n   const { transformer } = router._def._config;\n \n-  return async (client: ws.WebSocket, req: IncomingMessage) => {\n+  return (client: ws.WebSocket, req: IncomingMessage) => {\n+    type Context = inferRouterContext<TRouter>;\n+    type ContextResult = Result<Context>;\n+\n     const clientSubscriptions = new Map<number | string, AbortController>();\n     const abortController = new AbortController();\n\n@@ -122,26 +126,31 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n       );\n     }\n \n-    function createCtxPromise(\n+    async function createCtxPromise(\n       getConnectionParams: () => TRPCRequestInfo['connectionParams'],\n-    ): Promise<inferRouterContext<TRouter>> {\n-      return run(async () => {\n-        ctx = await createContext?.({\n-          req,\n-          res: client,\n-          info: {\n-            connectionParams: getConnectionParams(),\n-            calls: [],\n-            isBatchCall: false,\n-            accept: null,\n-            type: 'unknown',\n-            signal: abortController.signal,\n-            url: null,\n-          },\n-        });\n+    ): Promise<ContextResult> {\n+      try {\n+        return await run(async (): Promise<ContextResult> => {\n+          ctx = await createContext?.({\n+            req,\n+            res: client,\n+            info: {\n+              connectionParams: getConnectionParams(),\n+              calls: [],\n+              isBatchCall: false,\n+              accept: null,\n+              type: 'unknown',\n+              signal: abortController.signal,\n+              url: null,\n+            },\n+          });\n \n-        return ctx;\n-      }).catch((cause) => {\n+          return {\n+            ok: true,\n+            value: ctx,\n+          };\n+        });\n+      } catch (cause) {\n         const error = getTRPCErrorFromUnknown(cause);\n         opts.onError?.({\n           error,\n\n@@ -167,12 +176,14 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n         (globalThis.setImmediate ?? globalThis.setTimeout)(() => {\n           client.close();\n         });\n-\n-        throw error;\n-      });\n+        return {\n+          ok: false,\n+          error,\n+        };\n+      }\n     }\n \n-    let ctx: inferRouterContext<TRouter> | undefined = undefined;\n+    let ctx: Context | undefined = undefined;\n \n     /**\n      * promise for initializing the context\n\n@@ -182,18 +193,40 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n      */\n     let ctxPromise =\n       createURL(req).searchParams.get('connectionParams') === '1'\n-        ? unsetContextPromiseSymbol\n+        ? null\n         : createCtxPromise(() => null);\n \n-    async function handleRequest(msg: TRPCClientOutgoingMessage) {\n+    function handleRequest(msg: TRPCClientOutgoingMessage) {\n       const { id, jsonrpc } = msg;\n \n-      /* istanbul ignore next -- @preserve */\n       if (id === null) {\n-        throw new TRPCError({\n-          code: 'BAD_REQUEST',\n-          message: '`id` is required',\n+        const error = getTRPCErrorFromUnknown(\n+          new TRPCError({\n+            code: 'PARSE_ERROR',\n+            message: '`id` is required',\n+          }),\n+        );\n+        opts.onError?.({\n+          error,\n+          path: undefined,\n+          type: 'unknown',\n+          ctx,\n+          req,\n+          input: undefined,\n         });\n+        respond({\n+          id,\n+          jsonrpc,\n+          error: getErrorShape({\n+            config: router._def._config,\n+            error,\n+            type: 'unknown',\n+            path: undefined,\n+            input: undefined,\n+            ctx,\n+          }),\n+        });\n+        return;\n       }\n       if (msg.method === 'subscription.stop') {\n         clientSubscriptions.get(id)?.abort();\n\n@@ -202,20 +235,25 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n       const { path, lastEventId } = msg.params;\n       let { input } = msg.params;\n       const type = msg.method;\n-      try {\n-        if (lastEventId !== undefined) {\n-          if (isObject(input)) {\n-            input = {\n-              ...input,\n-              lastEventId: lastEventId,\n-            };\n-          } else {\n-            input ??= {\n-              lastEventId: lastEventId,\n-            };\n-          }\n+\n+      if (lastEventId !== undefined) {\n+        if (isObject(input)) {\n+          input = {\n+            ...input,\n+            lastEventId: lastEventId,\n+          };\n+        } else {\n+          input ??= {\n+            lastEventId: lastEventId,\n+          };\n+        }\n+      }\n+      run(async () => {\n+        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n+        const res = await ctxPromise!; // asserts context has been set\n+        if (!res.ok) {\n+          throw res.error;\n         }\n-        await ctxPromise; // asserts context has been set\n \n         const abortController = new AbortController();\n         const result = await callTRPCProcedure({\n\n@@ -384,7 +422,7 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n             type: 'started',\n           },\n         });\n-      } catch (cause) /* istanbul ignore next -- @preserve */ {\n+      }).catch((cause) => {\n         // procedure threw an error\n         const error = getTRPCErrorFromUnknown(cause);\n         opts.onError?.({ error, path, type, ctx, req, input });\n\n@@ -400,9 +438,9 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n             ctx,\n           }),\n         });\n-      }\n+      });\n     }\n-    client.on('message', async (rawData) => {\n+    client.on('message', (rawData) => {\n       // eslint-disable-next-line @typescript-eslint/no-base-to-string\n       const msgStr = rawData.toString();\n       if (msgStr === 'PONG') {\n\n@@ -414,7 +452,7 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n         }\n         return;\n       }\n-      if (ctxPromise === unsetContextPromiseSymbol) {\n+      if (!ctxPromise) {\n         // If the ctxPromise wasn't created immediately, we're expecting the first message to be a TRPCConnectionParamsMessage\n         ctxPromise = createCtxPromise(() => {\n           let msg;\n\n@@ -438,31 +476,36 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n         });\n         return;\n       }\n-      try {\n-        const msgJSON: unknown = JSON.parse(msgStr);\n-        const msgs: unknown[] = Array.isArray(msgJSON) ? msgJSON : [msgJSON];\n-        const promises = msgs\n-          .map((raw) => parseTRPCMessage(raw, transformer))\n-          .map(handleRequest);\n-        await Promise.all(promises);\n-      } catch (cause) {\n-        const error = new TRPCError({\n-          code: 'PARSE_ERROR',\n-          cause,\n-        });\n \n-        respond({\n-          id: null,\n-          error: getErrorShape({\n-            config: router._def._config,\n-            error,\n-            type: 'unknown',\n-            path: undefined,\n-            input: undefined,\n-            ctx: undefined,\n-          }),\n-        });\n-      }\n+      const parsedMsgs = run(() => {\n+        try {\n+          const msgJSON: unknown = JSON.parse(msgStr);\n+          const msgs: unknown[] = Array.isArray(msgJSON) ? msgJSON : [msgJSON];\n+\n+          return msgs.map((raw) => parseTRPCMessage(raw, transformer));\n+        } catch (cause) {\n+          const error = new TRPCError({\n+            code: 'PARSE_ERROR',\n+            cause,\n+          });\n+\n+          respond({\n+            id: null,\n+            error: getErrorShape({\n+              config: router._def._config,\n+              error,\n+              type: 'unknown',\n+              path: undefined,\n+              input: undefined,\n+              ctx,\n+            }),\n+          });\n+\n+          return [];\n+        }\n+      });\n+\n+      parsedMsgs.map(handleRequest);\n     });\n \n     // WebSocket errors should be handled, as otherwise unhandled exceptions will crash Node.js.\n\n@@ -487,10 +530,6 @@\nexport function getWSConnectionHandler<TRouter extends AnyRouter>(\n       clientSubscriptions.clear();\n       abortController.abort();\n     });\n-\n-    if (ctxPromise !== unsetContextPromiseSymbol) {\n-      await ctxPromise;\n-    }\n   };\n }\n\n@@ -544,22 +583,7 @@\nexport function applyWSSHandler<TRouter extends AnyRouter>(\n       return;\n     }\n \n-    onConnection(client, req).catch((cause) => {\n-      opts.onError?.({\n-        error: new TRPCError({\n-          code: 'INTERNAL_SERVER_ERROR',\n-          cause,\n-          message: 'Failed to handle WebSocket connection',\n-        }),\n-        req: req,\n-        path: undefined,\n-        type: 'unknown',\n-        ctx: undefined,\n-        input: undefined,\n-      });\n-\n-      client.close();\n-    });\n+    onConnection(client, req);\n   });\n \n   return {\n```\n\nFilename: packages/tests/server/websockets.test.ts:\n```\n@@ -12,7 +12,9 @@\nimport { observable, observableToAsyncIterable } from '@trpc/server/observable';\n import type {\n   TRPCClientOutgoingMessage,\n   TRPCRequestMessage,\n+  TRPCResponse,\n } from '@trpc/server/rpc';\n+import type { DefaultErrorShape } from '@trpc/server/unstable-core-do-not-import';\n import {\n   createDeferred,\n   sleep,\n\n@@ -1828,6 +1830,53 @@\ndescribe('auth / connectionParams', async () => {\n     });\n     expect(ctx.wss.clients.size).toBe(1);\n   });\n+\n+  test('regression: bad connection params', async () => {\n+    async function connect() {\n+      const ws = new WebSocket(ctx.wssUrl + '?connectionParams=1');\n+      await new Promise((resolve) => {\n+        ws.addEventListener('open', resolve);\n+      });\n+      function request(str: string) {\n+        ws.send(str);\n+        return new Promise<Res>((resolve, reject) => {\n+          ws.addEventListener('message', (it) => {\n+            resolve(JSON.parse(it.data as string));\n+          });\n+          ws.addEventListener('error', reject);\n+          ws.addEventListener('close', reject);\n+        });\n+      }\n+      return { request };\n+    }\n+\n+    type Res = TRPCResponse<unknown, DefaultErrorShape>;\n+\n+    const badConnectionParams = JSON.stringify({\n+      method: 'connectionParams',\n+      data: { invalidConnectionParams: null },\n+    });\n+\n+    {\n+      const client = await connect();\n+      const res = await client.request(badConnectionParams);\n+\n+      assert('error' in res);\n+      expect(res.error.message).toMatchInlineSnapshot(\n+        `\"Invalid connection params shape\"`,\n+      );\n+    }\n+\n+    {\n+      const client = await connect();\n+      const res = await client.request(badConnectionParams);\n+\n+      assert('error' in res);\n+      expect(res.error.message).toMatchInlineSnapshot(\n+        `\"Invalid connection params shape\"`,\n+      );\n+    }\n+  });\n });\n \n describe('subscriptions with createCaller', () => {\n```"
            }
        ],
        "sw_version": "v11.0.0",
        "sw_version_wget": "https://github.com/trpc/trpc/archive/refs/tags/v11.0.0.zip",
        "description": "tRPC allows users to build & consume fully typesafe APIs without schemas or code generation. In versions starting from 11.0.0 to before 11.1.1, an unhandled error is thrown when validating invalid connectionParams which crashes a tRPC WebSocket server. This allows any unauthenticated user to crash a tRPC 11 WebSocket server. Any tRPC 11 server with WebSocket enabled with a createContext method set is vulnerable. This issue has been patched in version 11.1.1.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-248",
                "value": "CWE-248: Uncaught Exception"
            }
        ]
    },
    "CVE-2025-0454": {
        "published_date": "2025-03-20T10:11:30.365Z",
        "patch_commits": [
            {
                "url": "https://github.com/significant-gravitas/autogpt/commit/ff065cd24c2289878c0abdb9adbf91c305f0d70a",
                "content": "Merge branch 'dev' into zamilmajdy/secrt-1010-ssrf-check-bypass-in-requests-utility-in-significant\n\nFilename: autogpt_platform/backend/backend/blocks/code_executor.py:\n```\n@@ -0,0 +1,191 @@\n+from enum import Enum\n+from typing import Literal\n+\n+from e2b_code_interpreter import Sandbox\n+from pydantic import SecretStr\n+\n+from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema\n+from backend.data.model import (\n+    APIKeyCredentials,\n+    CredentialsField,\n+    CredentialsMetaInput,\n+    SchemaField,\n+)\n+\n+TEST_CREDENTIALS = APIKeyCredentials(\n+    id=\"01234567-89ab-cdef-0123-456789abcdef\",\n+    provider=\"e2b\",\n+    api_key=SecretStr(\"mock-e2b-api-key\"),\n+    title=\"Mock E2B API key\",\n+    expires_at=None,\n+)\n+TEST_CREDENTIALS_INPUT = {\n+    \"provider\": TEST_CREDENTIALS.provider,\n+    \"id\": TEST_CREDENTIALS.id,\n+    \"type\": TEST_CREDENTIALS.type,\n+    \"title\": TEST_CREDENTIALS.type,\n+}\n+\n+\n+class ProgrammingLanguage(Enum):\n+    PYTHON = \"python\"\n+    JAVASCRIPT = \"js\"\n+    BASH = \"bash\"\n+    R = \"r\"\n+    JAVA = \"java\"\n+\n+\n+class CodeExecutionBlock(Block):\n+    # TODO : Add support to upload and download files\n+    # Currently, You can customized the CPU and Memory, only by creating a pre customized sandbox template\n+    class Input(BlockSchema):\n+        credentials: CredentialsMetaInput[Literal[\"e2b\"], Literal[\"api_key\"]] = (\n+            CredentialsField(\n+                provider=\"e2b\",\n+                supported_credential_types={\"api_key\"},\n+                description=\"Enter your api key for the E2B Sandbox. You can get it in here - https://e2b.dev/docs\",\n+            )\n+        )\n+\n+        # Todo : Option to run commond in background\n+        setup_commands: list[str] = SchemaField(\n+            description=(\n+                \"Shell commands to set up the sandbox before running the code. \"\n+                \"You can use `curl` or `git` to install your desired Debian based \"\n+                \"package manager. `pip` and `npm` are pre-installed.\\n\\n\"\n+                \"These commands are executed with `sh`, in the foreground.\"\n+            ),\n+            placeholder=\"pip install cowsay\",\n+            default=[],\n+            advanced=False,\n+        )\n+\n+        code: str = SchemaField(\n+            description=\"Code to execute in the sandbox\",\n+            placeholder=\"print('Hello, World!')\",\n+            default=\"\",\n+            advanced=False,\n+        )\n+\n+        language: ProgrammingLanguage = SchemaField(\n+            description=\"Programming language to execute\",\n+            default=ProgrammingLanguage.PYTHON,\n+            advanced=False,\n+        )\n+\n+        timeout: int = SchemaField(\n+            description=\"Execution timeout in seconds\", default=300\n+        )\n+\n+        template_id: str = SchemaField(\n+            description=(\n+                \"You can use an E2B sandbox template by entering its ID here. \"\n+                \"Check out the E2B docs for more details: \"\n+                \"[E2B - Sandbox template](https://e2b.dev/docs/sandbox-template)\"\n+            ),\n+            default=\"\",\n+            advanced=True,\n+        )\n+\n+    class Output(BlockSchema):\n+        response: str = SchemaField(description=\"Response from code execution\")\n+        stdout_logs: str = SchemaField(\n+            description=\"Standard output logs from execution\"\n+        )\n+        stderr_logs: str = SchemaField(description=\"Standard error logs from execution\")\n+        error: str = SchemaField(description=\"Error message if execution failed\")\n+\n+    def __init__(self):\n+        super().__init__(\n+            id=\"0b02b072-abe7-11ef-8372-fb5d162dd712\",\n+            description=\"Executes code in an isolated sandbox environment with internet access.\",\n+            categories={BlockCategory.DEVELOPER_TOOLS},\n+            input_schema=CodeExecutionBlock.Input,\n+            output_schema=CodeExecutionBlock.Output,\n+            test_credentials=TEST_CREDENTIALS,\n+            test_input={\n+                \"credentials\": TEST_CREDENTIALS_INPUT,\n+                \"code\": \"print('Hello World')\",\n+                \"language\": ProgrammingLanguage.PYTHON.value,\n+                \"setup_commands\": [],\n+                \"timeout\": 300,\n+                \"template_id\": \"\",\n+            },\n+            test_output=[\n+                (\"response\", \"Hello World\"),\n+                (\"stdout_logs\", \"Hello World\\n\"),\n+            ],\n+            test_mock={\n+                \"execute_code\": lambda code, language, setup_commands, timeout, api_key, template_id: (\n+                    \"Hello World\",\n+                    \"Hello World\\n\",\n+                    \"\",\n+                ),\n+            },\n+        )\n+\n+    def execute_code(\n+        self,\n+        code: str,\n+        language: ProgrammingLanguage,\n+        setup_commands: list[str],\n+        timeout: int,\n+        api_key: str,\n+        template_id: str,\n+    ):\n+        try:\n+            sandbox = None\n+            if template_id:\n+                sandbox = Sandbox(\n+                    template=template_id, api_key=api_key, timeout=timeout\n+                )\n+            else:\n+                sandbox = Sandbox(api_key=api_key, timeout=timeout)\n+\n+            if not sandbox:\n+                raise Exception(\"Sandbox not created\")\n+\n+            # Running setup commands\n+            for cmd in setup_commands:\n+                sandbox.commands.run(cmd)\n+\n+            # Executing the code\n+            execution = sandbox.run_code(\n+                code,\n+                language=language.value,\n+                on_error=lambda e: sandbox.kill(),  # Kill the sandbox if there is an error\n+            )\n+\n+            if execution.error:\n+                raise Exception(execution.error)\n+\n+            response = execution.text\n+            stdout_logs = \"\".join(execution.logs.stdout)\n+            stderr_logs = \"\".join(execution.logs.stderr)\n+\n+            return response, stdout_logs, stderr_logs\n+\n+        except Exception as e:\n+            raise e\n+\n+    def run(\n+        self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs\n+    ) -> BlockOutput:\n+        try:\n+            response, stdout_logs, stderr_logs = self.execute_code(\n+                input_data.code,\n+                input_data.language,\n+                input_data.setup_commands,\n+                input_data.timeout,\n+                credentials.api_key.get_secret_value(),\n+                input_data.template_id,\n+            )\n+\n+            if response:\n+                yield \"response\", response\n+            if stdout_logs:\n+                yield \"stdout_logs\", stdout_logs\n+            if stderr_logs:\n+                yield \"stderr_logs\", stderr_logs\n+        except Exception as e:\n+            yield \"error\", str(e)\n```\n\nFilename: autogpt_platform/backend/poetry.lock:\n```\n@@ -704,6 +704,42 @@\nfiles = [\n     {file = \"distro-1.9.0.tar.gz\", hash = \"sha256:2fa77c6fd8940f116ee1d6b94a2f90b13b5ea8d019b98bc8bafdcabcdd9bdbed\"},\n ]\n \n+[[package]]\n+name = \"e2b\"\n+version = \"1.0.4\"\n+description = \"E2B SDK that give agents cloud environments\"\n+optional = false\n+python-versions = \"<4.0,>=3.8\"\n+files = [\n+    {file = \"e2b-1.0.4-py3-none-any.whl\", hash = \"sha256:1a9c765eb1b2cc291c5ebd3f2e268f8fba9471a12f470f4651395b5753730170\"},\n+    {file = \"e2b-1.0.4.tar.gz\", hash = \"sha256:5ed3db4f984e52cf3aabb717725493ff060a8374b7c878b31bceeff46a0b5648\"},\n+]\n+\n+[package.dependencies]\n+attrs = \">=23.2.0\"\n+httpcore = \">=1.0.5,<2.0.0\"\n+httpx = \">=0.27.0,<0.28.0\"\n+packaging = \">=24.1\"\n+protobuf = \">=3.20.0,<6.0.0\"\n+python-dateutil = \">=2.8.2\"\n+typing-extensions = \">=4.1.0\"\n+\n+[[package]]\n+name = \"e2b-code-interpreter\"\n+version = \"1.0.1\"\n+description = \"E2B Code Interpreter - Stateful code execution\"\n+optional = false\n+python-versions = \"<4.0,>=3.8\"\n+files = [\n+    {file = \"e2b_code_interpreter-1.0.1-py3-none-any.whl\", hash = \"sha256:e27c40174ba7daac4942388611a73e1ac58300227f0ba6c0555ee54507d4944c\"},\n+    {file = \"e2b_code_interpreter-1.0.1.tar.gz\", hash = \"sha256:b0c061e41315d21514affe78f80052be335b687204e669dd7ca852b59eeaaea2\"},\n+]\n+\n+[package.dependencies]\n+attrs = \">=21.3.0\"\n+e2b = \">=1.0.0,<2.0.0\"\n+httpx = \">=0.20.0,<0.28.0\"\n+\n [[package]]\n name = \"exceptiongroup\"\n version = \"1.2.2\"\n\n@@ -4028,4 +4064,4 @@\ntype = [\"pytest-mypy\"]\n [metadata]\n lock-version = \"2.0\"\n python-versions = \"^3.10\"\n-content-hash = \"5bc61641d782791b76f39b18625560a6652b02f3ad788f110e0258293032c34a\"\n+content-hash = \"94dbe280c8215cd4ceef47c14b681092cb03964aa081b6cdb978da7bbf818593\"\n```\n\nFilename: autogpt_platform/backend/pyproject.toml:\n```\n@@ -16,6 +16,7 @@\nautogpt-libs = { path = \"../autogpt_libs\", develop = true }\n click = \"^8.1.7\"\n croniter = \"^5.0.1\"\n discord-py = \"^2.4.0\"\n+e2b-code-interpreter = \"^1.0.1\"\n fastapi = \"^0.115.5\"\n feedparser = \"^6.0.11\"\n flake8 = \"^7.0.0\"\n```\n\nFilename: autogpt_platform/frontend/src/components/integrations/credentials-input.tsx:\n```\n@@ -48,6 +48,7 @@\nexport const providerIcons: Record<\n   React.FC<{ className?: string }>\n > = {\n   anthropic: fallbackIcon,\n+  e2b: fallbackIcon,\n   github: FaGithub,\n   google: FaGoogle,\n   groq: fallbackIcon,\n```\n\nFilename: autogpt_platform/frontend/src/components/integrations/credentials-provider.tsx:\n```\n@@ -24,6 +24,7 @@\nconst providerDisplayNames: Record<CredentialsProviderName, string> = {\n   anthropic: \"Anthropic\",\n   discord: \"Discord\",\n   d_id: \"D-ID\",\n+  e2b: \"E2B\",\n   github: \"GitHub\",\n   google: \"Google\",\n   google_maps: \"Google Maps\",\n```\n\nFilename: autogpt_platform/frontend/src/lib/autogpt-server-api/types.ts:\n```\n@@ -102,6 +102,7 @@\nexport const PROVIDER_NAMES = {\n   ANTHROPIC: \"anthropic\",\n   D_ID: \"d_id\",\n   DISCORD: \"discord\",\n+  E2B: \"e2b\",\n   GITHUB: \"github\",\n   GOOGLE: \"google\",\n   GOOGLE_MAPS: \"google_maps\",\n```"
            }
        ],
        "sw_version": "v0.3.1",
        "sw_version_wget": "https://github.com/significant-gravitas/autogpt/archive/refs/tags/v0.3.1.zip",
        "description": "A Server-Side Request Forgery (SSRF) vulnerability was identified in the Requests utility of significant-gravitas/autogpt versions prior to v0.4.0. The vulnerability arises due to a hostname confusion between the `urlparse` function from the `urllib.parse` library and the `requests` library. A malicious user can exploit this by submitting a specially crafted URL, such as `http://localhost:\\@google.com/../`, to bypass the SSRF check and perform an SSRF attack.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-918",
                "value": "CWE-918 Server-Side Request Forgery (SSRF)"
            }
        ]
    },
    "CVE-2025-30370": {
        "published_date": "2025-04-03T22:00:44.476Z",
        "patch_commits": [
            {
                "url": "https://github.com/jupyterlab/jupyterlab-git/commit/b46482993f76d3a546015c6a94ebed8b77fc2376",
                "content": "Merge commit from fork\n\nSee the advisory for more details.\n\nFilename: src/commandsAndMenu.tsx:\n```\n@@ -164,31 +164,13 @@\nexport function addCommands(\n     label: trans.__('Open Git Repository in Terminal'),\n     caption: trans.__('Open a New Terminal to the Git Repository'),\n     execute: async args => {\n-      const main = (await commands.execute(\n-        'terminal:create-new',\n-        args\n-      )) as MainAreaWidget<ITerminal.ITerminal>;\n+      const cwd = gitModel.pathRepository;\n+      const main = (await commands.execute('terminal:create-new', {\n+        ...args,\n+        cwd\n+      })) as MainAreaWidget<ITerminal.ITerminal>;\n \n-      try {\n-        if (gitModel.pathRepository !== null) {\n-          const terminal = main.content;\n-          terminal.session.send({\n-            type: 'stdin',\n-            content: [\n-              `cd \"${gitModel.pathRepository\n-                .split('\"')\n-                .join('\\\\\"')\n-                .split('`')\n-                .join('\\\\`')}\"\\n`\n-            ]\n-          });\n-        }\n-\n-        return main;\n-      } catch (e) {\n-        console.error(e);\n-        main.dispose();\n-      }\n+      return main;\n     },\n     isEnabled: () =>\n       gitModel.pathRepository !== null &&\n```"
            }
        ],
        "sw_version": "v0.51.0",
        "sw_version_wget": "https://github.com/jupyterlab/jupyterlab-git/archive/refs/tags/v0.51.0.zip",
        "description": "jupyterlab-git is a JupyterLab extension for version control using Git. On many platforms, a third party can create a Git repository under a name that includes a shell command substitution string in the syntax $(<command>). These directory names are allowed in macOS and a majority of Linux distributions. If a user starts jupyter-lab in a parent directory of this inappropriately-named Git repository, opens it, and clicks \"Git > Open Git Repository in Terminal\" from the menu bar, then the injected command <command> is run in the user's shell without the user's permission. This issue is occurring because when that menu entry is clicked, jupyterlab-git opens the terminal and runs cd <git-repo-path> through the shell to set the current directory. Doing so runs any command substitution strings present in the directory name, which leads to the command injection issue described here. A previous patch provided an incomplete fix. This vulnerability is fixed in 0.51.1.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-78",
                "value": "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
            }
        ]
    },
    "CVE-2025-31481": {
        "cwe": [
            {
                "id": "CWE-863",
                "value": "CWE-863: Incorrect Authorization"
            }
        ],
        "description": "API Platform Core is a system to create hypermedia-driven REST and GraphQL APIs. Using the Relay special node type you can bypass the configured security on an operation. This vulnerability is fixed in 4.0.22 and 3.4.17.",
        "languages": [
            "PHP"
        ],
        "patch_commits": [
            {
                "content": "fix(graphql): access to unauthorized resource using node Relay\n\nFilename: src/GraphQl/Metadata/RuntimeOperationMetadataFactory.php:\n```\n@@ -0,0 +1,55 @@\n+<?php\n+\n+/*\n+ * This file is part of the API Platform project.\n+ *\n+ * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n+ *\n+ * For the full copyright and license information, please view the LICENSE\n+ * file that was distributed with this source code.\n+ */\n+\n+declare(strict_types=1);\n+\n+namespace ApiPlatform\\GraphQl\\Metadata;\n+\n+use ApiPlatform\\Metadata\\Exception\\InvalidArgumentException;\n+use ApiPlatform\\Metadata\\GraphQl\\Query;\n+use ApiPlatform\\Metadata\\Operation;\n+use ApiPlatform\\Metadata\\Operation\\Factory\\OperationMetadataFactoryInterface;\n+use ApiPlatform\\Metadata\\Resource\\Factory\\ResourceMetadataCollectionFactoryInterface;\n+use Symfony\\Component\\Routing\\Exception\\ExceptionInterface as RoutingExceptionInterface;\n+use Symfony\\Component\\Routing\\RouterInterface;\n+\n+/**\n+ * This factory runs in the ResolverFactory and is used to find out a Relay node's operation.\n+ */\n+final class RuntimeOperationMetadataFactory implements OperationMetadataFactoryInterface\n+{\n+    public function __construct(private readonly ResourceMetadataCollectionFactoryInterface $resourceMetadataCollectionFactory, private readonly RouterInterface $router)\n+    {\n+    }\n+\n+    public function create(string $uriTemplate, array $context = []): ?Operation\n+    {\n+        try {\n+            $parameters = $this->router->match($uriTemplate);\n+        } catch (RoutingExceptionInterface $e) {\n+            throw new InvalidArgumentException(\\sprintf('No route matches \"%s\".', $uriTemplate), $e->getCode(), $e);\n+        }\n+\n+        if (!isset($parameters['_api_resource_class'])) {\n+            throw new InvalidArgumentException(\\sprintf('The route \"%s\" is not an API route, it has no resource class in the defaults.', $uriTemplate));\n+        }\n+\n+        foreach ($this->resourceMetadataCollectionFactory->create($parameters['_api_resource_class']) as $resource) {\n+            foreach ($resource->getGraphQlOperations() ?? [] as $operation) {\n+                if ($operation instanceof Query && !$operation->getResolver()) {\n+                    return $operation;\n+                }\n+            }\n+        }\n+\n+        throw new InvalidArgumentException(\\sprintf('No operation found for id \"%s\".', $uriTemplate));\n+    }\n+}\n```\n\nFilename: src/GraphQl/Resolver/Factory/ResolverFactory.php:\n```\n@@ -15,21 +15,28 @@\nuse ApiPlatform\\GraphQl\\State\\Provider\\NoopProvider;\n use ApiPlatform\\Metadata\\DeleteOperationInterface;\n+use ApiPlatform\\Metadata\\Exception\\InvalidArgumentException;\n use ApiPlatform\\Metadata\\GraphQl\\Mutation;\n use ApiPlatform\\Metadata\\GraphQl\\Operation;\n use ApiPlatform\\Metadata\\GraphQl\\Query;\n+use ApiPlatform\\Metadata\\Operation\\Factory\\OperationMetadataFactoryInterface;\n use ApiPlatform\\Metadata\\Property\\Factory\\PropertyMetadataFactoryInterface;\n use ApiPlatform\\State\\Pagination\\ArrayPaginator;\n use ApiPlatform\\State\\ProcessorInterface;\n use ApiPlatform\\State\\ProviderInterface;\n use GraphQL\\Type\\Definition\\ResolveInfo;\n+use Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\n \n class ResolverFactory implements ResolverFactoryInterface\n {\n     public function __construct(\n         private readonly ProviderInterface $provider,\n         private readonly ProcessorInterface $processor,\n+        private readonly ?OperationMetadataFactoryInterface $operationMetadataFactory = null,\n     ) {\n+        if (!$operationMetadataFactory) {\n+            throw new InvalidArgumentException(\\sprintf('Not injecting the \"%s\" exposes Relay nodes to a security risk.', OperationMetadataFactoryInterface::class));\n+        }\n     }\n \n     public function __invoke(?string $resourceClass = null, ?string $rootClass = null, ?Operation $operation = null, ?PropertyMetadataFactoryInterface $propertyMetadataFactory = null): callable\n\n@@ -70,7 +77,13 @@\npublic function __invoke(?string $resourceClass = null, ?string $rootClass = nul\n     private function resolve(?array $source, array $args, ResolveInfo $info, ?string $rootClass = null, ?Operation $operation = null, mixed $body = null)\n     {\n         // Handles relay nodes\n-        $operation ??= new Query();\n+        if (!$operation) {\n+            if (!isset($args['id'])) {\n+                throw new NotFoundHttpException('No node found.');\n+            }\n+\n+            $operation = $this->operationMetadataFactory->create($args['id']);\n+        }\n \n         $graphQlContext = [];\n         $context = ['source' => $source, 'args' => $args, 'info' => $info, 'root_class' => $rootClass, 'graphql_context' => &$graphQlContext];\n```\n\nFilename: src/GraphQl/Tests/Metadata/RuntimeOperationMetadataFactoryTest.php:\n```\n@@ -0,0 +1,144 @@\n+<?php\n+\n+/*\n+ * This file is part of the API Platform project.\n+ *\n+ * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n+ *\n+ * For the full copyright and license information, please view the LICENSE\n+ * file that was distributed with this source code.\n+ */\n+\n+declare(strict_types=1);\n+\n+namespace ApiPlatform\\GraphQl\\Tests\\Metadata;\n+\n+use ApiPlatform\\GraphQl\\Metadata\\RuntimeOperationMetadataFactory;\n+use ApiPlatform\\Metadata\\ApiResource;\n+use ApiPlatform\\Metadata\\GraphQl\\Query;\n+use ApiPlatform\\Metadata\\Resource\\Factory\\ResourceMetadataCollectionFactoryInterface;\n+use ApiPlatform\\Metadata\\Resource\\ResourceMetadataCollection;\n+use PHPUnit\\Framework\\TestCase;\n+use Symfony\\Component\\Routing\\Exception\\ResourceNotFoundException;\n+use Symfony\\Component\\Routing\\RouterInterface;\n+\n+class RuntimeOperationMetadataFactoryTest extends TestCase\n+{\n+    public function testCreate(): void\n+    {\n+        $resourceClass = 'Dummy';\n+        $operationName = 'item_query';\n+\n+        $operation = (new Query())->withName($operationName);\n+        $resourceMetadata = (new ApiResource())->withGraphQlOperations([$operationName => $operation]);\n+        $resourceMetadataCollection = new ResourceMetadataCollection($resourceClass, [$resourceMetadata]);\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+        $resourceMetadataCollectionFactory->expects($this->once())\n+            ->method('create')\n+            ->with($resourceClass)\n+            ->willReturn($resourceMetadataCollection);\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/dummies/1')\n+            ->willReturn([\n+                '_api_resource_class' => $resourceClass,\n+                '_api_operation_name' => $operationName,\n+            ]);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $this->assertEquals($operation, $factory->create('/dummies/1'));\n+    }\n+\n+    public function testCreateThrowsExceptionWhenRouteNotFound(): void\n+    {\n+        $this->expectException(\\ApiPlatform\\Metadata\\Exception\\InvalidArgumentException::class);\n+        $this->expectExceptionMessage('No route matches \"/unknown\".');\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/unknown')\n+            ->willThrowException(new ResourceNotFoundException());\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $factory->create('/unknown');\n+    }\n+\n+    public function testCreateThrowsExceptionWhenResourceClassMissing(): void\n+    {\n+        $this->expectException(\\ApiPlatform\\Metadata\\Exception\\InvalidArgumentException::class);\n+        $this->expectExceptionMessage('The route \"/dummies/1\" is not an API route, it has no resource class in the defaults.');\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/dummies/1')\n+            ->willReturn([]);\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $factory->create('/dummies/1');\n+    }\n+\n+    public function testCreateThrowsExceptionWhenOperationNotFound(): void\n+    {\n+        $this->expectException(\\ApiPlatform\\Metadata\\Exception\\InvalidArgumentException::class);\n+        $this->expectExceptionMessage('No operation found for id \"/dummies/1\".');\n+\n+        $resourceClass = 'Dummy';\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+        $resourceMetadataCollectionFactory->expects($this->once())\n+            ->method('create')\n+            ->with($resourceClass)\n+            ->willReturn(new ResourceMetadataCollection($resourceClass, [new ApiResource()]));\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/dummies/1')\n+            ->willReturn([\n+                '_api_resource_class' => $resourceClass,\n+            ]);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $factory->create('/dummies/1');\n+    }\n+\n+    public function testCreateIgnoresOperationsWithResolvers(): void\n+    {\n+        $this->expectException(\\ApiPlatform\\Metadata\\Exception\\InvalidArgumentException::class);\n+        $this->expectExceptionMessage('No operation found for id \"/dummies/1\".');\n+\n+        $resourceClass = 'Dummy';\n+        $operationName = 'item_query';\n+\n+        $operation = (new Query())->withResolver('t')->withName($operationName);\n+        $resourceMetadata = (new ApiResource())->withGraphQlOperations([$operationName => $operation]);\n+        $resourceMetadataCollection = new ResourceMetadataCollection($resourceClass, [$resourceMetadata]);\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+        $resourceMetadataCollectionFactory->expects($this->once())\n+            ->method('create')\n+            ->with($resourceClass)\n+            ->willReturn($resourceMetadataCollection);\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/dummies/1')\n+            ->willReturn([\n+                '_api_resource_class' => $resourceClass,\n+                '_api_operation_name' => $operationName,\n+            ]);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $factory->create('/dummies/1');\n+    }\n+}\n```\n\nFilename: src/GraphQl/Tests/Resolver/Factory/ResolverFactoryTest.php:\n```\n@@ -18,6 +18,7 @@\nuse ApiPlatform\\Metadata\\GraphQl\\Mutation;\n use ApiPlatform\\Metadata\\GraphQl\\Operation;\n use ApiPlatform\\Metadata\\GraphQl\\Query;\n+use ApiPlatform\\Metadata\\Operation\\Factory\\OperationMetadataFactoryInterface;\n use ApiPlatform\\Metadata\\Property\\Factory\\PropertyMetadataFactoryInterface;\n use ApiPlatform\\State\\ProcessorInterface;\n use ApiPlatform\\State\\ProviderInterface;\n\n@@ -45,7 +46,7 @@\npublic function testGraphQlResolver(?string $resourceClass = null, ?string $root\n         $resolveInfo = $this->createMock(ResolveInfo::class);\n         $resolveInfo->fieldName = 'test';\n \n-        $resolverFactory = new ResolverFactory($provider, $processor);\n+        $resolverFactory = new ResolverFactory($provider, $processor, $this->createMock(OperationMetadataFactoryInterface::class));\n         $this->assertEquals($resolverFactory->__invoke($resourceClass, $rootClass, $operation, $propertyMetadataFactory)(['test' => null], [], [], $resolveInfo), $returnValue);\n     }\n\n@@ -56,4 +57,21 @@\npublic static function graphQlQueries(): array\n             ['Dummy', 'Dummy', new Mutation(), (new Mutation())->withValidate(true), (new Mutation())->withValidate(true)->withWrite(true)],\n         ];\n     }\n+\n+    public function testGraphQlResolverWithNode(): void\n+    {\n+        $returnValue = new \\stdClass();\n+        $op = new Query(name: 'hi');\n+        $provider = $this->createMock(ProviderInterface::class);\n+        $provider->expects($this->once())->method('provide')->with($op)->willReturn($returnValue);\n+        $processor = $this->createMock(ProcessorInterface::class);\n+        $processor->expects($this->once())->method('process')->with($returnValue, $op)->willReturn($returnValue);\n+        $resolveInfo = $this->createMock(ResolveInfo::class);\n+        $resolveInfo->fieldName = 'test';\n+\n+        $operationFactory = $this->createMock(OperationMetadataFactoryInterface::class);\n+        $operationFactory->method('create')->with('/foo')->willReturn($op);\n+        $resolverFactory = new ResolverFactory($provider, $processor, $operationFactory);\n+        $this->assertSame($returnValue, $resolverFactory->__invoke()([], ['id' => '/foo'], [], $resolveInfo));\n+    }\n }\n```\n\nFilename: src/Metadata/Resource/Factory/OperationDefaultsTrait.php:\n```\n@@ -112,7 +112,7 @@\nprivate function getDefaultHttpOperations($resource): iterable\n \n     private function addDefaultGraphQlOperations(ApiResource $resource): ApiResource\n     {\n-        $operations = enum_exists($resource->getClass()) ? [new QueryCollection(paginationEnabled: false), new Query()] : [new QueryCollection(), new Query(), (new Mutation())->withName('update'), (new DeleteMutation())->withName('delete'), (new Mutation())->withName('create')];\n+        $operations = enum_exists($resource->getClass()) ? [new Query(), new QueryCollection(paginationEnabled: false)] : [new Query(), new QueryCollection(), (new Mutation())->withName('update'), (new DeleteMutation())->withName('delete'), (new Mutation())->withName('create')];\n         $graphQlOperations = [];\n         foreach ($operations as $operation) {\n             [$key, $operation] = $this->getOperationWithDefaults($resource, $operation);\n```\n\nFilename: src/Symfony/Bundle/Resources/config/graphql.xml:\n```\n@@ -191,6 +191,12 @@\n<service id=\"api_platform.graphql.resolver.factory.item\" class=\"ApiPlatform\\GraphQl\\Resolver\\Factory\\ResolverFactory\" public=\"false\">\n             <argument type=\"service\" id=\"api_platform.graphql.state_provider\" />\n             <argument type=\"service\" id=\"api_platform.graphql.state_processor\" />\n+            <argument type=\"service\" id=\"api_platform.graphql.runtime_operation_metadata_factory\" />\n+        </service>\n+\n+        <service id=\"api_platform.graphql.runtime_operation_metadata_factory\" class=\"ApiPlatform\\GraphQl\\Metadata\\RuntimeOperationMetadataFactory\" public=\"false\">\n+            <argument type=\"service\" id=\"api_platform.metadata.resource.metadata_collection_factory\" />\n+            <argument type=\"service\" id=\"api_platform.router\" />\n         </service>\n \n         <!-- Resolver Stages -->\n```\n\nFilename: tests/Functional/GraphQl/SecurityTest.php:\n```\n@@ -26,7 +26,6 @@\nfinal class SecurityTest extends ApiTestCase\n {\n     use RecreateSchemaTrait;\n     use SetupClassResourcesTrait;\n-    protected static ?bool $alwaysBootKernel = false;\n \n     /**\n      * @return class-string[]\n```",
                "url": "https://github.com/api-platform/core/commit/55712452b4f630978537bdb2a07dc958202336bb"
            },
            {
                "content": "fix(graphql): access to unauthorized resource using node Relay\n\nFilename: src/GraphQl/Metadata/RuntimeOperationMetadataFactory.php:\n```\n@@ -0,0 +1,55 @@\n+<?php\n+\n+/*\n+ * This file is part of the API Platform project.\n+ *\n+ * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n+ *\n+ * For the full copyright and license information, please view the LICENSE\n+ * file that was distributed with this source code.\n+ */\n+\n+declare(strict_types=1);\n+\n+namespace ApiPlatform\\GraphQl\\Metadata;\n+\n+use ApiPlatform\\Metadata\\Exception\\InvalidArgumentException;\n+use ApiPlatform\\Metadata\\GraphQl\\Query;\n+use ApiPlatform\\Metadata\\Operation;\n+use ApiPlatform\\Metadata\\Operation\\Factory\\OperationMetadataFactoryInterface;\n+use ApiPlatform\\Metadata\\Resource\\Factory\\ResourceMetadataCollectionFactoryInterface;\n+use Symfony\\Component\\Routing\\Exception\\ExceptionInterface as RoutingExceptionInterface;\n+use Symfony\\Component\\Routing\\RouterInterface;\n+\n+/**\n+ * This factory runs in the ResolverFactory and is used to find out a Relay node's operation.\n+ */\n+final class RuntimeOperationMetadataFactory implements OperationMetadataFactoryInterface\n+{\n+    public function __construct(private readonly ResourceMetadataCollectionFactoryInterface $resourceMetadataCollectionFactory, private readonly RouterInterface $router)\n+    {\n+    }\n+\n+    public function create(string $uriTemplate, array $context = []): ?Operation\n+    {\n+        try {\n+            $parameters = $this->router->match($uriTemplate);\n+        } catch (RoutingExceptionInterface $e) {\n+            throw new InvalidArgumentException(\\sprintf('No route matches \"%s\".', $uriTemplate), $e->getCode(), $e);\n+        }\n+\n+        if (!isset($parameters['_api_resource_class'])) {\n+            throw new InvalidArgumentException(\\sprintf('The route \"%s\" is not an API route, it has no resource class in the defaults.', $uriTemplate));\n+        }\n+\n+        foreach ($this->resourceMetadataCollectionFactory->create($parameters['_api_resource_class']) as $resource) {\n+            foreach ($resource->getGraphQlOperations() ?? [] as $operation) {\n+                if ($operation instanceof Query && !$operation->getResolver()) {\n+                    return $operation;\n+                }\n+            }\n+        }\n+\n+        throw new InvalidArgumentException(\\sprintf('No operation found for id \"%s\".', $uriTemplate));\n+    }\n+}\n```\n\nFilename: src/GraphQl/Resolver/Factory/ResolverFactory.php:\n```\n@@ -15,21 +15,28 @@\nuse ApiPlatform\\GraphQl\\State\\Provider\\NoopProvider;\n use ApiPlatform\\Metadata\\DeleteOperationInterface;\n+use ApiPlatform\\Metadata\\Exception\\InvalidArgumentException;\n use ApiPlatform\\Metadata\\GraphQl\\Mutation;\n use ApiPlatform\\Metadata\\GraphQl\\Operation;\n use ApiPlatform\\Metadata\\GraphQl\\Query;\n+use ApiPlatform\\Metadata\\Operation\\Factory\\OperationMetadataFactoryInterface;\n use ApiPlatform\\Metadata\\Property\\Factory\\PropertyMetadataFactoryInterface;\n use ApiPlatform\\State\\Pagination\\ArrayPaginator;\n use ApiPlatform\\State\\ProcessorInterface;\n use ApiPlatform\\State\\ProviderInterface;\n use GraphQL\\Type\\Definition\\ResolveInfo;\n+use Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\n \n class ResolverFactory implements ResolverFactoryInterface\n {\n     public function __construct(\n         private readonly ProviderInterface $provider,\n         private readonly ProcessorInterface $processor,\n+        private readonly ?OperationMetadataFactoryInterface $operationMetadataFactory = null,\n     ) {\n+        if (!$operationMetadataFactory) {\n+            throw new InvalidArgumentException(\\sprintf('Not injecting the \"%s\" exposes Relay nodes to a security risk.', OperationMetadataFactoryInterface::class));\n+        }\n     }\n \n     public function __invoke(?string $resourceClass = null, ?string $rootClass = null, ?Operation $operation = null, ?PropertyMetadataFactoryInterface $propertyMetadataFactory = null): callable\n\n@@ -70,7 +77,13 @@\npublic function __invoke(?string $resourceClass = null, ?string $rootClass = nul\n     private function resolve(?array $source, array $args, ResolveInfo $info, ?string $rootClass = null, ?Operation $operation = null, mixed $body = null)\n     {\n         // Handles relay nodes\n-        $operation ??= new Query();\n+        if (!$operation) {\n+            if (!isset($args['id'])) {\n+                throw new NotFoundHttpException('No node found.');\n+            }\n+\n+            $operation = $this->operationMetadataFactory->create($args['id']);\n+        }\n \n         $graphQlContext = [];\n         $context = ['source' => $source, 'args' => $args, 'info' => $info, 'root_class' => $rootClass, 'graphql_context' => &$graphQlContext];\n```\n\nFilename: src/GraphQl/Tests/Metadata/RuntimeOperationMetadataFactoryTest.php:\n```\n@@ -0,0 +1,144 @@\n+<?php\n+\n+/*\n+ * This file is part of the API Platform project.\n+ *\n+ * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n+ *\n+ * For the full copyright and license information, please view the LICENSE\n+ * file that was distributed with this source code.\n+ */\n+\n+declare(strict_types=1);\n+\n+namespace ApiPlatform\\GraphQl\\Tests\\Metadata;\n+\n+use ApiPlatform\\GraphQl\\Metadata\\RuntimeOperationMetadataFactory;\n+use ApiPlatform\\Metadata\\ApiResource;\n+use ApiPlatform\\Metadata\\GraphQl\\Query;\n+use ApiPlatform\\Metadata\\Resource\\Factory\\ResourceMetadataCollectionFactoryInterface;\n+use ApiPlatform\\Metadata\\Resource\\ResourceMetadataCollection;\n+use PHPUnit\\Framework\\TestCase;\n+use Symfony\\Component\\Routing\\Exception\\ResourceNotFoundException;\n+use Symfony\\Component\\Routing\\RouterInterface;\n+\n+class RuntimeOperationMetadataFactoryTest extends TestCase\n+{\n+    public function testCreate(): void\n+    {\n+        $resourceClass = 'Dummy';\n+        $operationName = 'item_query';\n+\n+        $operation = (new Query())->withName($operationName);\n+        $resourceMetadata = (new ApiResource())->withGraphQlOperations([$operationName => $operation]);\n+        $resourceMetadataCollection = new ResourceMetadataCollection($resourceClass, [$resourceMetadata]);\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+        $resourceMetadataCollectionFactory->expects($this->once())\n+            ->method('create')\n+            ->with($resourceClass)\n+            ->willReturn($resourceMetadataCollection);\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/dummies/1')\n+            ->willReturn([\n+                '_api_resource_class' => $resourceClass,\n+                '_api_operation_name' => $operationName,\n+            ]);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $this->assertEquals($operation, $factory->create('/dummies/1'));\n+    }\n+\n+    public function testCreateThrowsExceptionWhenRouteNotFound(): void\n+    {\n+        $this->expectException(\\ApiPlatform\\Metadata\\Exception\\InvalidArgumentException::class);\n+        $this->expectExceptionMessage('No route matches \"/unknown\".');\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/unknown')\n+            ->willThrowException(new ResourceNotFoundException());\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $factory->create('/unknown');\n+    }\n+\n+    public function testCreateThrowsExceptionWhenResourceClassMissing(): void\n+    {\n+        $this->expectException(\\ApiPlatform\\Metadata\\Exception\\InvalidArgumentException::class);\n+        $this->expectExceptionMessage('The route \"/dummies/1\" is not an API route, it has no resource class in the defaults.');\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/dummies/1')\n+            ->willReturn([]);\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $factory->create('/dummies/1');\n+    }\n+\n+    public function testCreateThrowsExceptionWhenOperationNotFound(): void\n+    {\n+        $this->expectException(\\ApiPlatform\\Metadata\\Exception\\InvalidArgumentException::class);\n+        $this->expectExceptionMessage('No operation found for id \"/dummies/1\".');\n+\n+        $resourceClass = 'Dummy';\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+        $resourceMetadataCollectionFactory->expects($this->once())\n+            ->method('create')\n+            ->with($resourceClass)\n+            ->willReturn(new ResourceMetadataCollection($resourceClass, [new ApiResource()]));\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/dummies/1')\n+            ->willReturn([\n+                '_api_resource_class' => $resourceClass,\n+            ]);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $factory->create('/dummies/1');\n+    }\n+\n+    public function testCreateIgnoresOperationsWithResolvers(): void\n+    {\n+        $this->expectException(\\ApiPlatform\\Metadata\\Exception\\InvalidArgumentException::class);\n+        $this->expectExceptionMessage('No operation found for id \"/dummies/1\".');\n+\n+        $resourceClass = 'Dummy';\n+        $operationName = 'item_query';\n+\n+        $operation = (new Query())->withResolver('t')->withName($operationName);\n+        $resourceMetadata = (new ApiResource())->withGraphQlOperations([$operationName => $operation]);\n+        $resourceMetadataCollection = new ResourceMetadataCollection($resourceClass, [$resourceMetadata]);\n+\n+        $resourceMetadataCollectionFactory = $this->createMock(ResourceMetadataCollectionFactoryInterface::class);\n+        $resourceMetadataCollectionFactory->expects($this->once())\n+            ->method('create')\n+            ->with($resourceClass)\n+            ->willReturn($resourceMetadataCollection);\n+\n+        $router = $this->createMock(RouterInterface::class);\n+        $router->expects($this->once())\n+            ->method('match')\n+            ->with('/dummies/1')\n+            ->willReturn([\n+                '_api_resource_class' => $resourceClass,\n+                '_api_operation_name' => $operationName,\n+            ]);\n+\n+        $factory = new RuntimeOperationMetadataFactory($resourceMetadataCollectionFactory, $router);\n+        $factory->create('/dummies/1');\n+    }\n+}\n```\n\nFilename: src/GraphQl/Tests/Resolver/Factory/ResolverFactoryTest.php:\n```\n@@ -18,6 +18,7 @@\nuse ApiPlatform\\Metadata\\GraphQl\\Mutation;\n use ApiPlatform\\Metadata\\GraphQl\\Operation;\n use ApiPlatform\\Metadata\\GraphQl\\Query;\n+use ApiPlatform\\Metadata\\Operation\\Factory\\OperationMetadataFactoryInterface;\n use ApiPlatform\\Metadata\\Property\\Factory\\PropertyMetadataFactoryInterface;\n use ApiPlatform\\State\\ProcessorInterface;\n use ApiPlatform\\State\\ProviderInterface;\n\n@@ -43,7 +44,7 @@\npublic function testGraphQlResolver(?string $resourceClass = null, ?string $root\n         $resolveInfo = $this->createMock(ResolveInfo::class);\n         $resolveInfo->fieldName = 'test';\n \n-        $resolverFactory = new ResolverFactory($provider, $processor);\n+        $resolverFactory = new ResolverFactory($provider, $processor, $this->createMock(OperationMetadataFactoryInterface::class));\n         $this->assertEquals($resolverFactory->__invoke($resourceClass, $rootClass, $operation, $propertyMetadataFactory)(['test' => null], [], [], $resolveInfo), $returnValue);\n     }\n\n@@ -54,4 +55,21 @@\npublic static function graphQlQueries(): array\n             ['Dummy', 'Dummy', new Mutation(), (new Mutation())->withValidate(true), (new Mutation())->withValidate(true)->withWrite(true)],\n         ];\n     }\n+\n+    public function testGraphQlResolverWithNode(): void\n+    {\n+        $returnValue = new \\stdClass();\n+        $op = new Query(name: 'hi');\n+        $provider = $this->createMock(ProviderInterface::class);\n+        $provider->expects($this->once())->method('provide')->with($op)->willReturn($returnValue);\n+        $processor = $this->createMock(ProcessorInterface::class);\n+        $processor->expects($this->once())->method('process')->with($returnValue, $op)->willReturn($returnValue);\n+        $resolveInfo = $this->createMock(ResolveInfo::class);\n+        $resolveInfo->fieldName = 'test';\n+\n+        $operationFactory = $this->createMock(OperationMetadataFactoryInterface::class);\n+        $operationFactory->method('create')->with('/foo')->willReturn($op);\n+        $resolverFactory = new ResolverFactory($provider, $processor, $operationFactory);\n+        $this->assertSame($returnValue, $resolverFactory->__invoke()([], ['id' => '/foo'], [], $resolveInfo));\n+    }\n }\n```\n\nFilename: src/Laravel/ApiPlatformProvider.php:\n```\n@@ -17,6 +17,7 @@\nuse ApiPlatform\\GraphQl\\Error\\ErrorHandlerInterface;\n use ApiPlatform\\GraphQl\\Executor;\n use ApiPlatform\\GraphQl\\ExecutorInterface;\n+use ApiPlatform\\GraphQl\\Metadata\\RuntimeOperationMetadataFactory;\n use ApiPlatform\\GraphQl\\Resolver\\Factory\\ResolverFactory;\n use ApiPlatform\\GraphQl\\Resolver\\Factory\\ResolverFactoryInterface;\n use ApiPlatform\\GraphQl\\Resolver\\QueryCollectionResolverInterface;\n\n@@ -1273,7 +1274,15 @@\nprivate function registerGraphQl(Application $app): void\n         $app->singleton(ResolverFactoryInterface::class, function (Application $app) {\n             return new ResolverFactory(\n                 $app->make('api_platform.graphql.state_provider.access_checker'),\n-                $app->make('api_platform.graphql.state_processor')\n+                $app->make('api_platform.graphql.state_processor'),\n+                $app->make('api_platform.graphql.runtime_operation_metadata_factory'),\n+            );\n+        });\n+\n+        $app->singleton('api_platform.graphql.runtime_operation_metadata_factory', function (Application $app) {\n+            return new RuntimeOperationMetadataFactory(\n+                $app->make(ResourceMetadataCollectionFactoryInterface::class),\n+                $app->make(UrlGeneratorRouter::class)\n             );\n         });\n```\n\nFilename: src/Metadata/Resource/Factory/OperationDefaultsTrait.php:\n```\n@@ -121,7 +121,7 @@\nprivate function getDefaultHttpOperations($resource): iterable\n \n     private function addDefaultGraphQlOperations(ApiResource $resource): ApiResource\n     {\n-        $operations = enum_exists($resource->getClass()) ? [new QueryCollection(paginationEnabled: false), new Query()] : [new QueryCollection(), new Query(), (new Mutation())->withName('update'), (new DeleteMutation())->withName('delete'), (new Mutation())->withName('create')];\n+        $operations = enum_exists($resource->getClass()) ? [new Query(), new QueryCollection(paginationEnabled: false)] : [new Query(), new QueryCollection(), (new Mutation())->withName('update'), (new DeleteMutation())->withName('delete'), (new Mutation())->withName('create')];\n         $graphQlOperations = [];\n         foreach ($operations as $operation) {\n             [$key, $operation] = $this->getOperationWithDefaults($resource, $operation);\n```\n\nFilename: src/Symfony/Bundle/Resources/config/graphql.xml:\n```\n@@ -187,6 +187,12 @@\n<service id=\"api_platform.graphql.resolver.factory\" class=\"ApiPlatform\\GraphQl\\Resolver\\Factory\\ResolverFactory\" public=\"false\">\n             <argument type=\"service\" id=\"api_platform.graphql.state_provider\" />\n             <argument type=\"service\" id=\"api_platform.graphql.state_processor\" />\n+            <argument type=\"service\" id=\"api_platform.graphql.runtime_operation_metadata_factory\" />\n+        </service>\n+\n+        <service id=\"api_platform.graphql.runtime_operation_metadata_factory\" class=\"ApiPlatform\\GraphQl\\Metadata\\RuntimeOperationMetadataFactory\" public=\"false\">\n+            <argument type=\"service\" id=\"api_platform.metadata.resource.metadata_collection_factory\" />\n+            <argument type=\"service\" id=\"api_platform.router\" />\n         </service>\n \n         <!-- Resolver Stages -->\n```\n\nFilename: tests/Functional/GraphQl/SecurityTest.php:\n```\n@@ -0,0 +1,116 @@\n+<?php\n+\n+/*\n+ * This file is part of the API Platform project.\n+ *\n+ * (c) K\u00e9vin Dunglas <dunglas@gmail.com>\n+ *\n+ * For the full copyright and license information, please view the LICENSE\n+ * file that was distributed with this source code.\n+ */\n+\n+declare(strict_types=1);\n+\n+namespace ApiPlatform\\Tests\\Functional\\GraphQl;\n+\n+use ApiPlatform\\Symfony\\Bundle\\Test\\ApiTestCase;\n+use ApiPlatform\\Tests\\Fixtures\\TestBundle\\Document\\SecuredDummy as DocumentSecuredDummy;\n+use ApiPlatform\\Tests\\Fixtures\\TestBundle\\Entity\\SecuredDummy;\n+use ApiPlatform\\Tests\\RecreateSchemaTrait;\n+use ApiPlatform\\Tests\\SetupClassResourcesTrait;\n+\n+final class SecurityTest extends ApiTestCase\n+{\n+    use RecreateSchemaTrait;\n+    use SetupClassResourcesTrait;\n+\n+    /**\n+     * @return class-string[]\n+     */\n+    public static function getResources(): array\n+    {\n+        return [SecuredDummy::class];\n+    }\n+\n+    public function testQueryItem(): void\n+    {\n+        $resource = $this->isMongoDB() ? DocumentSecuredDummy::class : SecuredDummy::class;\n+        $this->recreateSchema([$resource]);\n+        $this->loadFixtures($resource);\n+        $client = self::createClient();\n+        $response = $client->request('POST', '/graphql', ['json' => [\n+            'query' => <<<QUERY\n+    {\n+      securedDummy(id: \"/secured_dummies/1\") {\n+        title\n+        description\n+      }\n+    }\n+QUERY,\n+        ]]);\n+\n+        $d = $response->toArray();\n+        $this->assertEquals('Access Denied.', $d['errors'][0]['message']);\n+    }\n+\n+    public function testCreateItemUnauthorized(): void\n+    {\n+        $resource = $this->isMongoDB() ? DocumentSecuredDummy::class : SecuredDummy::class;\n+        $this->recreateSchema([$resource]);\n+        $client = self::createClient();\n+        $response = $client->request('POST', '/graphql', ['json' => [\n+            'query' => <<<QUERY\n+mutation {\n+    createSecuredDummy(input: {owner: \"me\", title: \"Hi\", description: \"Desc\", adminOnlyProperty: \"secret\", clientMutationId: \"auth\"}) {\n+        securedDummy {\n+            title\n+            owner\n+        }\n+    }\n+}\n+QUERY,\n+        ]]);\n+\n+        $d = $response->toArray();\n+        $this->assertEquals('Only admins can create a secured dummy.', $d['errors'][0]['message']);\n+    }\n+\n+    public function testQueryItemWithNode(): void\n+    {\n+        $resource = $this->isMongoDB() ? DocumentSecuredDummy::class : SecuredDummy::class;\n+        $this->recreateSchema([$resource]);\n+        $this->loadFixtures($resource);\n+        $client = self::createClient();\n+        $response = $client->request('POST', '/graphql', ['json' => [\n+            'query' => <<<QUERY\n+    {\n+      node(id: \"/secured_dummies/1\") {\n+        ... on SecuredDummy {\n+            title\n+        }\n+      }\n+    }\n+QUERY,\n+        ]]);\n+\n+        $d = $response->toArray();\n+        $this->assertEquals('Access Denied.', $d['errors'][0]['message']);\n+    }\n+\n+    public function loadFixtures(string $resourceClass): void\n+    {\n+        $container = static::$kernel->getContainer();\n+        $registry = $this->isMongoDB() ? $container->get('doctrine_mongodb') : $container->get('doctrine');\n+        $manager = $registry->getManager();\n+        $s = new $resourceClass();\n+        $s->setTitle('Secured Dummy 1');\n+        $s->setDescription('Description 1');\n+        $s->setAdminOnlyProperty('admin secret');\n+        $s->setOwnerOnlyProperty('owner secret');\n+        $s->setAttributeBasedProperty('attribute based secret');\n+        $s->setOwner('user1');\n+\n+        $manager->persist($s);\n+        $manager->flush();\n+    }\n+}\n```",
                "url": "https://github.com/api-platform/core/commit/60747cc8c2fb855798c923b5537888f8d0969568"
            }
        ],
        "published_date": "2025-04-03T19:20:22.916Z",
        "sec_adv": [],
        "sw_version": "v4.0.0",
        "sw_version_wget": "https://github.com/api-platform/core/archive/refs/tags/v4.0.0.zip"
    },
    "CVE-2025-27092": {
        "published_date": "2025-02-19T22:16:56.207Z",
        "patch_commits": [
            {
                "url": "https://github.com/cmu-sei/GHOSTS/commit/e69827556a52ff813de00e1017c4b62598d2c887",
                "content": "Mitigates directory traversal [XBOW-025-109]\n\nFilename: src/Ghosts.Api/Controllers/Api/NpcsController.cs:\n```\n@@ -16,10 +16,11 @@\nusing Ghosts.Animator.Extensions;\n using Ghosts.Animator.Models;\n using Ghosts.Api.Infrastructure.Data;\n-using Ghosts.Api.Infrastructure.Extensions;\n+using ghosts.api.Infrastructure.Extensions;\n using Ghosts.Domain.Code;\n using Microsoft.AspNetCore.Mvc;\n using Microsoft.EntityFrameworkCore;\n+using NLog;\n using Swashbuckle.AspNetCore.Annotations;\n using Swashbuckle.AspNetCore.Filters;\n\n@@ -30,8 +31,7 @@\nnamespace ghosts.api.Controllers.Api;\n [Route(\"api/[controller]\")]\n public class NpcsController(ApplicationDbContext context, INpcService service) : ControllerBase\n {\n-    private readonly ApplicationDbContext _context = context;\n-    private readonly INpcService _service = service;\n+    private static readonly Logger _log = LogManager.GetCurrentClassLogger();\n \n     /// <summary>\n     /// Returns all generated NPCs in the system (caution, could return a very large amount of data)\n\n@@ -43,7 +43,7 @@\npublic class NpcsController(ApplicationDbContext context, INpcService service) :\n     [HttpGet]\n     public async Task<ActionResult<IEnumerable<NpcRecord>>> NpcsGetAll()\n     {\n-        return Ok(await _service.GetAll());\n+        return Ok(await service.GetAll());\n     }\n \n     /// <summary>\n\n@@ -56,7 +56,7 @@\npublic async Task<ActionResult<IEnumerable<NpcRecord>>> NpcsGetAll()\n     [HttpPost]\n     public async Task<ActionResult<IEnumerable<NpcRecord>>> NpcsCreate(NpcProfile npc)\n     {\n-        return Ok(await _service.CreateOne(npc));\n+        return Ok(await service.CreateOne(npc));\n     }\n \n     /// <summary>\n\n@@ -69,7 +69,7 @@\npublic async Task<ActionResult<IEnumerable<NpcRecord>>> NpcsCreate(NpcProfile np\n     [HttpGet(\"list\")]\n     public async Task<ActionResult<IEnumerable<NpcNameId>>> NpcsGetList()\n     {\n-        return Ok(await _service.GetListAsync());\n+        return Ok(await service.GetListAsync());\n     }\n \n     /// <summary>\n\n@@ -83,7 +83,7 @@\npublic async Task<ActionResult<IEnumerable<NpcNameId>>> NpcsGetList()\n     [HttpGet(\"{id:guid}\")]\n     public async Task<ActionResult<NpcRecord>> NpcsGetById(Guid id)\n     {\n-        return Ok(await _service.GetById(id));\n+        return Ok(await service.GetById(id));\n     }\n \n     /// <summary>\n\n@@ -97,7 +97,7 @@\npublic async Task<ActionResult<NpcRecord>> NpcsGetById(Guid id)\n     [HttpDelete(\"{id:guid}\")]\n     public async Task NpcsDeleteById(Guid id)\n     {\n-        await _service.DeleteById(id);\n+        await service.DeleteById(id);\n     }\n \n     /// <summary>\n\n@@ -112,7 +112,7 @@\npublic async Task NpcsDeleteById(Guid id)\n     public async Task<IActionResult> NpcsGetAvatarById(Guid id)\n     {\n         // Get NPC and find image\n-        var npc = await _service.GetById(id);\n+        var npc = await service.GetById(id);\n         if (npc == null) return NotFound();\n \n         // Determine the image path\n\n@@ -123,11 +123,26 @@\npublic async Task<IActionResult> NpcsGetAvatarById(Guid id)\n         // Check if the image file exists\n         if (!System.IO.File.Exists(imagePath))\n         {\n+            _log.Warn($\"Npc {id} \u2014 File does not exist! {imagePath} \u2014 switching to default npc image\");\n+            imagePath = ApplicationDetails.ConfigurationFiles.DefaultNpcImage;\n+        }\n+\n+        // is path within the app? is it a jpg?\n+        if (!imagePath.IsPathWithinAppScope(ApplicationDetails.InstalledPath))\n+        {\n+            _log.Warn($\"Npc {id} \u2014 Bad image path! {imagePath} \u2014 switching to default npc image\");\n+            imagePath = ApplicationDetails.ConfigurationFiles.DefaultNpcImage;\n+        }\n+\n+        // is an image?\n+        if (!new HashSet<string> { \".jpg\", \".jpeg\", \".png\" }.Contains(Path.GetExtension(imagePath)?.ToLower()))\n+        {\n+            _log.Warn($\"Npc {id} \u2014 Not an image! {imagePath} \u2014 switching to default npc image\");\n             imagePath = ApplicationDetails.ConfigurationFiles.DefaultNpcImage;\n         }\n \n         // Load image as stream and return as file result\n-        var stream = new FileStream(imagePath, FileMode.Open, FileAccess.Read);\n+        var stream = new FileStream(imagePath!, FileMode.Open, FileAccess.Read);\n         return File(stream, \"image/jpg\", $\"{npc.NpcProfile.Name.ToString()!.Replace(\" \", \"_\")}.jpg\");\n     }\n\n@@ -147,7 +162,7 @@\npublic async Task<object> NpcsGetReducedFields(Guid npcId, [FromBody] string[] f\n             return BadRequest(ModelState);\n         }\n \n-        var npc = await _service.GetById(npcId);\n+        var npc = await service.GetById(npcId);\n         if (npc == null) return null;\n         return new NPCReduced(fieldsToReturn, npc).PropertySelection;\n     }\n\n@@ -164,7 +179,7 @@\npublic async Task<object> NpcsGetReducedFields(Guid npcId, [FromBody] string[] f\n     [HttpGet(\"{campaign}/{enclave}\")]\n     public async Task<IEnumerable<NpcRecord>> NpcsEnclaveGet(string campaign, string enclave)\n     {\n-        return await _service.GetEnclave(campaign, enclave);\n+        return await service.GetEnclave(campaign, enclave);\n     }\n \n     /// <summary>\n\n@@ -207,8 +222,8 @@\npublic async Task<IActionResult> NpcsEnclaveGetCsv(string campaign, string encla\n     public async Task NpcsEnclaveDelete(string campaign, string enclave)\n     {\n         var list = await NpcsEnclaveGet(campaign, enclave);\n-        _context.Npcs.RemoveRange(list);\n-        await _context.SaveChangesAsync();\n+        context.Npcs.RemoveRange(list);\n+        await context.SaveChangesAsync();\n     }\n \n     /// <summary>\n\n@@ -256,7 +271,7 @@\npublic async Task<IActionResult> NpcsEnclaveReducedFields(string campaign, strin\n     [HttpGet(\"{campaign}/{enclave}/{team}\")]\n     public async Task<IEnumerable<NpcRecord>> NpcsTeamGet(string campaign, string enclave, string team)\n     {\n-        return await _service.GetTeam(campaign, enclave, team);\n+        return await service.GetTeam(campaign, enclave, team);\n     }\n \n     /// <summary>\n\n@@ -311,7 +326,7 @@\npublic async Task<IActionResult> NpcsTfVarsGet(TfVarsConfiguration configuration\n \n         var pool = configuration.GetIpPool();\n         foreach (var item in pool)\n-            if (_context.NpcIps.Any(o => o.IpAddress == item && o.Enclave == configuration.Enclave))\n+            if (context.NpcIps.Any(o => o.IpAddress == item && o.Enclave == configuration.Enclave))\n                 pool.Remove(item);\n \n         if (pool.Count < list.Count())\n\n@@ -330,7 +345,7 @@\npublic async Task<IActionResult> NpcsTfVarsGet(TfVarsConfiguration configuration\n             }\n \n             var ip = pool.RandomElement();\n-            _context.NpcIps.Add(new NPCIpAddress { IpAddress = ip, NpcId = npc.Id, Enclave = npc.Enclave });\n+            context.NpcIps.Add(new NPCIpAddress { IpAddress = ip, NpcId = npc.Id, Enclave = npc.Enclave });\n             pool.Remove(ip);\n \n             s.Append(\"\\tuser-\").Append(i).Append(\" = {\").Append(Environment.NewLine);\n\n@@ -352,7 +367,7 @@\npublic async Task<IActionResult> NpcsTfVarsGet(TfVarsConfiguration configuration\n             i++;\n         }\n \n-        _context.SaveChanges();\n+        context.SaveChanges();\n \n         return File(Encoding.UTF8.GetBytes\n                 (s.ToString()), \"text/tfvars\", $\"{Guid.NewGuid()}.tfvars\");\n\n@@ -420,8 +435,8 @@\npublic async Task<ActionResult<IEnumerable<NpcRecord>>> NpcsInsiderThreatCreate(\n             }\n         }\n \n-        _context.Npcs.AddRange(createdNpcs);\n-        await _context.SaveChangesAsync(ct);\n+        context.Npcs.AddRange(createdNpcs);\n+        await context.SaveChangesAsync(ct);\n         return createdNpcs;\n     }\n\n@@ -439,7 +454,7 @@\npublic async Task<IActionResult> NpcsInsiderThreatGetCsv()\n         var engine = new FileHelperEngine<NPCToInsiderThreatCsv>();\n         engine.HeaderText = engine.GetFileHeader();\n \n-        var list = await _context.Npcs.ToListAsync();\n+        var list = await context.Npcs.ToListAsync();\n         var finalList = NPCToInsiderThreatCsv.ConvertToCsv(list.ToList());\n \n         var stream = new MemoryStream();\n```\n\nFilename: src/Ghosts.Api/Infrastructure/Extensions/DirectoryExtensions.cs:\n```\n@@ -0,0 +1,24 @@\n+// Copyright 2017 Carnegie Mellon University. All Rights Reserved. See LICENSE.md file for terms.\n+\n+using System;\n+using System.IO;\n+\n+namespace ghosts.api.Infrastructure.Extensions;\n+\n+public static class DirectoryExtensions\n+{\n+    public static bool IsPathWithinAppScope(this string targetPath, string root)\n+    {\n+        try\n+        {\n+            var fullRootPath = Path.GetFullPath(root).TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar;\n+            var fullTargetPath = Path.GetFullPath(Path.Combine(fullRootPath, targetPath));\n+\n+            return fullTargetPath.StartsWith(fullRootPath, StringComparison.OrdinalIgnoreCase);\n+        }\n+        catch\n+        {\n+            return false;\n+        }\n+    }\n+}\n```"
            }
        ],
        "sw_version": "v8.0.0",
        "sw_version_wget": "https://github.com/cmu-sei/GHOSTS/archive/refs/tags/v8.0.0.zip",
        "description": "GHOSTS is an open source user simulation framework for cyber experimentation, simulation, training, and exercise. A path traversal vulnerability was discovered in GHOSTS version 8.0.0.0 that allows an attacker to access files outside of the intended directory through the photo retrieval endpoint. The vulnerability exists in the /api/npcs/{id}/photo endpoint, which is designed to serve profile photos for NPCs (Non-Player Characters) but fails to properly validate and sanitize file paths. When an NPC is created with a specially crafted photoLink value containing path traversal sequences (../, ..\\, etc.), the application processes these sequences without proper sanitization. This allows an attacker to traverse directory structures and access files outside of the intended photo directory, potentially exposing sensitive system files. The vulnerability is particularly severe because it allows reading arbitrary files from the server's filesystem with the permissions of the web application process, which could include configuration files, credentials, or other sensitive data. This issue has been addressed in version 8.2.7.90 and all users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-22",
                "value": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
            }
        ]
    },
    "CVE-2025-1944": {
        "published_date": "2025-03-10T11:30:32.896Z",
        "patch_commits": [
            {
                "url": "https://github.com/mmaitre314/picklescan/commit/e58e45e0d9e091159c1554f9b04828bbb40b9781",
                "content": "Merge commit from fork\n\n* more relaxed ZipFile impl\n\n* lint\n\n---------\n\nCo-authored-by: Matthieu Maitre <mmaitre@live.com>\n\nFilename: src/picklescan/relaxed_zipfile.py:\n```\n@@ -0,0 +1,88 @@\n+import struct\n+import zipfile\n+\n+# More forgiving implementation of zipfile.ZipFile\n+_FH_SIGNATURE = 0\n+_FH_FILENAME_LENGTH = 10\n+_FH_EXTRA_FIELD_LENGTH = 11\n+\n+structFileHeader = \"<4s2B4HL2L2H\"\n+stringFileHeader = b\"PK\\003\\004\"\n+sizeFileHeader = struct.calcsize(structFileHeader)\n+\n+\n+class RelaxedZipFile(zipfile.ZipFile):\n+    def open(self, name, mode=\"r\", pwd=None, *, force_zip64=False):\n+        # near copy of zipfile.ZipFile.open with\n+        \"\"\"Return file-like object for 'name'.\n+\n+        name is a string for the file name within the ZIP file, or a ZipInfo\n+        object.\n+\n+        mode should be 'r' to read a file already in the ZIP file, or 'w' to\n+        write to a file newly added to the archive.\n+\n+        pwd is the password to decrypt files (only used for reading).\n+\n+        When writing, if the file size is not known in advance but may exceed\n+        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large\n+        files.  If the size is known in advance, it is best to pass a ZipInfo\n+        instance for name, with zinfo.file_size set.\n+        \"\"\"\n+        if mode not in {\"r\", \"w\"}:\n+            raise ValueError('open() requires mode \"r\" or \"w\"')\n+        if pwd and not isinstance(pwd, bytes):\n+            raise TypeError(\"pwd: expected bytes, got %s\" % type(pwd).__name__)\n+        if pwd and (mode == \"w\"):\n+            raise ValueError(\"pwd is only supported for reading files\")\n+        if not self.fp:\n+            raise ValueError(\"Attempt to use ZIP archive that was already closed\")\n+\n+        # Make sure we have an info object\n+        if isinstance(name, zipfile.ZipInfo):\n+            # 'name' is already an info object\n+            zinfo = name\n+        elif mode == \"w\":\n+            zinfo = zipfile.ZipInfo(name)\n+            zinfo.compress_type = self.compression\n+            zinfo._compresslevel = self.compresslevel\n+        else:\n+            # Get info object for name\n+            zinfo = self.getinfo(name)\n+\n+        if mode == \"w\":\n+            return self._open_to_write(zinfo, force_zip64=force_zip64)\n+\n+        if self._writing:\n+            raise ValueError(\n+                \"Can't read from the ZIP file while there \"\n+                \"is an open writing handle on it. \"\n+                \"Close the writing handle before trying to read.\"\n+            )\n+\n+        # Open for reading:\n+        self._fileRefCnt += 1\n+        zef_file = zipfile._SharedFile(\n+            self.fp,\n+            zinfo.header_offset,\n+            self._fpclose,\n+            self._lock,\n+            lambda: self._writing,\n+        )\n+        try:\n+            # Skip the file header:\n+            fheader = zef_file.read(sizeFileHeader)\n+            if len(fheader) != sizeFileHeader:\n+                raise zipfile.BadZipFile(\"Truncated file header\")\n+            fheader = struct.unpack(structFileHeader, fheader)\n+            if fheader[_FH_SIGNATURE] != stringFileHeader:\n+                raise zipfile.BadZipFile(\"Bad magic number for file header\")\n+\n+            zef_file.read(fheader[_FH_FILENAME_LENGTH])\n+            if fheader[_FH_EXTRA_FIELD_LENGTH]:\n+                zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])\n+\n+            return zipfile.ZipExtFile(zef_file, mode, zinfo, pwd, True)\n+        except BaseException:\n+            zef_file.close()\n+            raise\n```\n\nFilename: src/picklescan/scanner.py:\n```\n@@ -11,6 +11,7 @@\nfrom typing import IO, List, Optional, Set, Tuple\n import urllib.parse\n import zipfile\n+from .relaxed_zipfile import RelaxedZipFile\n \n from .torch import (\n     get_magic_number,\n\n@@ -375,7 +376,7 @@\ndef get_magic_bytes_from_zipfile(zip: zipfile.ZipFile, num_bytes=8):\n def scan_zip_bytes(data: IO[bytes], file_id) -> ScanResult:\n     result = ScanResult([])\n \n-    with zipfile.ZipFile(data, \"r\") as zip:\n+    with RelaxedZipFile(data, \"r\") as zip:\n         magic_bytes = get_magic_bytes_from_zipfile(zip)\n         file_names = zip.namelist()\n         _log.debug(\"Files in zip archive %s: %s\", file_id, file_names)\n```\n\nFilename: tests/data/malicious1_0x1.zip:\n```\n\n```\n\nFilename: tests/data/malicious1_0x20.zip:\n```\n\n```\n\nFilename: tests/data/malicious1_0x40.zip:\n```\n\n```\n\nFilename: tests/data/malicious1_central_directory.zip:\n```\n\n```\n\nFilename: tests/test_scanner.py:\n```\n@@ -249,6 +249,22 @@\ndef initialize_zip_file(path, file_name, data):\n             zip.writestr(file_name, data)\n \n \n+def initialize_corrupt_zip_file_central_directory(path, file_name, data):\n+    if not os.path.exists(path):\n+        with zipfile.ZipFile(path, \"w\") as zip:\n+            zip.writestr(file_name, data)\n+\n+        with open(path, \"rb\") as f:\n+            data = f.read()\n+\n+        # Replace only the first occurrence of \"data.pkl\" with \"datap.kl\"\n+        modified_data = data.replace(b\"data.pkl\", b\"datap.kl\", 1)\n+\n+        # Write back the modified content\n+        with open(path, \"wb\") as f:\n+            f.write(modified_data)\n+\n+\n def initialize_numpy_files():\n     import numpy as np\n\n@@ -490,6 +506,12 @@\ndef initialize_pickle_files():\n         pickle.dumps(Malicious1(), protocol=4),\n     )\n \n+    initialize_corrupt_zip_file_central_directory(\n+        f\"{_root_path}/data/malicious1_central_directory.zip\",\n+        \"data.pkl\",\n+        pickle.dumps(Malicious1(), protocol=4),\n+    )\n+\n     initialize_zip_file(\n         f\"{_root_path}/data/malicious1_wrong_ext.zip\",\n         \"data.txt\",  # Pickle file with a non-standard extension\n\n@@ -646,7 +668,22 @@\ndef test_scan_file_path():\n     compare_scan_results(\n         scan_file_path(f\"{_root_path}/data/malicious1.zip\"), malicious1\n     )\n-    compare_scan_results(scan_file_path(f\"{_root_path}/data/malicious1.7z\"), malicious1)\n+    compare_scan_results(\n+        scan_file_path(f\"{_root_path}/data/malicious1_central_directory.zip\"),\n+        malicious1,\n+    )\n+    compare_scan_results(\n+        scan_file_path(f\"{_root_path}/data/malicious1_0x1.zip\"), malicious1\n+    )\n+    compare_scan_results(\n+        scan_file_path(f\"{_root_path}/data/malicious1_0x20.zip\"), malicious1\n+    )\n+    compare_scan_results(\n+        scan_file_path(f\"{_root_path}/data/malicious1_0x40.zip\"), malicious1\n+    )\n+    compare_scan_results(\n+        scan_file_path(f\"{_root_path}/data/malicious1.7z\"), malicious1\n+    )\n     compare_scan_results(\n         scan_file_path(f\"{_root_path}/data/malicious1_wrong_ext.zip\"), malicious1\n     )\n\n@@ -835,6 +872,9 @@\ndef test_scan_directory_path():\n             Global(\"functools\", \"partial\", SafetyLevel.Dangerous),\n             Global(\"pip\", \"main\", SafetyLevel.Dangerous),\n             Global(\"builtins\", \"eval\", SafetyLevel.Dangerous),\n+            Global(\"builtins\", \"eval\", SafetyLevel.Dangerous),\n+            Global(\"builtins\", \"eval\", SafetyLevel.Dangerous),\n+            Global(\"builtins\", \"eval\", SafetyLevel.Dangerous),\n         ],\n         scanned_files=38,\n         issues_count=39,\n```"
            }
        ],
        "sw_version": "v0.0.22",
        "sw_version_wget": "https://github.com/mmaitre314/picklescan/archive/refs/tags/v0.0.22.zip",
        "description": "picklescan before 0.0.23 is vulnerable to a ZIP archive manipulation attack that causes it to crash when attempting to extract and scan PyTorch model archives. By modifying the filename in the ZIP header while keeping the original filename in the directory listing, an attacker can make PickleScan raise a BadZipFile error. However, PyTorch's more forgiving ZIP implementation still allows the model to be loaded, enabling malicious payloads to bypass detection.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-345",
                "value": "CWE-345 Insufficient Verification of Data Authenticity"
            }
        ]
    },
    "CVE-2025-25288": {
        "published_date": "2025-02-14T19:33:43.428Z",
        "patch_commits": [
            {
                "url": "https://github.com/octokit/plugin-paginate-rest.js/commit/bb6c4f945d8023902cf387391d2b2209261044ab",
                "content": "Merge commit from fork\n\n* regular expression term vulnerability\n\n* regular expression term vulnerability\n\nFilename: src/iterator.ts:\n```\n@@ -37,7 +37,7 @@\nexport function iterator(\n           // '<https://api.github.com/users/aseemk/followers?page=2>; rel=\"next\", <https://api.github.com/users/aseemk/followers?page=2>; rel=\"last\"'\n           // sets `url` to undefined if \"next\" URL is not present or `link` header is not set\n           url = ((normalizedResponse.headers.link || \"\").match(\n-            /<([^>]+)>;\\s*rel=\"next\"/,\n+            /<([^<>]+)>;\\s*rel=\"next\"/,\n           ) || [])[1];\n \n           return { value: normalizedResponse };\n```\n\nFilename: test/paginate.test.ts:\n```\n@@ -10,6 +10,38 @@\nconst ORG2 = { id: 2 };\n \n const TestOctokit = Octokit.plugin(paginateRest, restEndpointMethods);\n describe(\"pagination\", () => {\n+  it(\"Test ReDoS - attack string\", async () => {\n+    const ReDosOctokit = Octokit.plugin(paginateRest);\n+    const octokit = new ReDosOctokit({\n+      auth: \"your-github-token\",\n+    });\n+    octokit.hook.wrap(\"request\", async (request, options) => {\n+      const maliciousLinkHeader = \"\" + \"<\".repeat(100000) + \">\";\n+      return {\n+        data: [],\n+        headers: {\n+          link: maliciousLinkHeader,\n+        },\n+      };\n+    });\n+    const startTime = performance.now();\n+    try {\n+      for await (const normalizedResponse of octokit.paginate.iterator(\n+        \"GET /repos/{owner}/{repo}/issues\", { owner: \"DayShift\", repo: \"ReDos\", per_page: 100 }\n+      )) {}\n+    } catch (error) {\n+      // pass\n+    }\n+    const endTime = performance.now();\n+    const elapsedTime = endTime - startTime;\n+    const reDosThreshold = 2000; \n+    \n+    expect(elapsedTime).toBeLessThanOrEqual(reDosThreshold);\n+    if (elapsedTime > reDosThreshold) {\n+      console.warn(`\ud83d\udea8 Potential ReDoS Attack! getDuration method took ${elapsedTime.toFixed(2)} ms, exceeding threshold of ${reDosThreshold} ms.`);\n+    }\n+  });\n+\n   it(\".paginate()\", async () => {\n     const mock = fetchMock\n       .createInstance()\n```"
            }
        ],
        "sw_version": "v1.0.0",
        "sw_version_wget": "https://github.com/octokit/plugin-paginate-rest.js/archive/refs/tags/v1.0.0.zip",
        "description": "@octokit/plugin-paginate-rest is the Octokit plugin to paginate REST API endpoint responses. For versions starting in 1.0.0 and prior to 11.4.1 of the npm package `@octokit/plugin-paginate-rest`, when calling `octokit.paginate.iterator()`, a specially crafted `octokit` instance\u2014particularly with a malicious `link` parameter in the `headers` section of the `request`\u2014can trigger a ReDoS attack. Version 11.4.1 contains a fix for the issue.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-1333",
                "value": "CWE-1333: Inefficient Regular Expression Complexity"
            }
        ]
    },
    "CVE-2025-24963": {
        "published_date": "2025-02-04T19:36:52.385Z",
        "patch_commits": [
            {
                "url": "https://github.com/vitest-dev/vitest/commit/2d62051f13b4b0939b2f7e94e88006d830dc4d1f",
                "content": "feat(browser): allow preview and open in the editor screenshot error from ui (#6113)\n\nFilename: packages/browser/src/node/plugin.ts:\n```\n@@ -1,7 +1,8 @@\nimport { fileURLToPath } from 'node:url'\n import { createRequire } from 'node:module'\n-import { readFileSync } from 'node:fs'\n-import { basename, resolve } from 'pathe'\n+import { lstatSync, readFileSync } from 'node:fs'\n+import type { Stats } from 'node:fs'\n+import { basename, extname, resolve } from 'pathe'\n import sirv from 'sirv'\n import type { WorkspaceProject } from 'vitest/node'\n import { getFilePoolName, resolveApiServerConfig, resolveFsAllow, distDir as vitestDist } from 'vitest/node'\n\n@@ -100,6 +101,52 @@\nexport default (browserServer: BrowserServer, base = '/'): Plugin[] => {\n             },\n           }),\n         )\n+\n+        const screenshotFailures = project.config.browser.ui && project.config.browser.screenshotFailures\n+\n+        // eslint-disable-next-line prefer-arrow-callback\n+        screenshotFailures && server.middlewares.use(`${base}__screenshot-error`, function vitestBrowserScreenshotError(req, res) {\n+          if (!req.url || !browserServer.provider) {\n+            res.statusCode = 404\n+            res.end()\n+            return\n+          }\n+\n+          const url = new URL(req.url, 'http://localhost')\n+          const file = url.searchParams.get('file')\n+          if (!file) {\n+            res.statusCode = 404\n+            res.end()\n+            return\n+          }\n+\n+          let stat: Stats | undefined\n+          try {\n+            stat = lstatSync(file)\n+          }\n+          catch (_) {\n+          }\n+\n+          if (!stat?.isFile()) {\n+            res.statusCode = 404\n+            res.end()\n+            return\n+          }\n+\n+          const ext = extname(file)\n+          const buffer = readFileSync(file)\n+          res.setHeader(\n+            'Cache-Control',\n+            'public,max-age=0,must-revalidate',\n+          )\n+          res.setHeader('Content-Length', buffer.length)\n+          res.setHeader('Content-Type', ext === 'jpeg' || ext === 'jpg'\n+            ? 'image/jpeg'\n+            : ext === 'webp'\n+              ? 'image/webp'\n+              : 'image/png')\n+          res.end(buffer)\n+        })\n       },\n     },\n     {\n```\n\nFilename: packages/ui/client/components.d.ts:\n```\n@@ -27,6 +27,7 @@\ndeclare module 'vue' {\n     ProgressBar: typeof import('./components/ProgressBar.vue')['default']\n     RouterLink: typeof import('vue-router')['RouterLink']\n     RouterView: typeof import('vue-router')['RouterView']\n+    ScreenshotError: typeof import('./components/views/ScreenshotError.vue')['default']\n     StatusIcon: typeof import('./components/StatusIcon.vue')['default']\n     TestFilesEntry: typeof import('./components/dashboard/TestFilesEntry.vue')['default']\n     TestsEntry: typeof import('./components/dashboard/TestsEntry.vue')['default']\n```\n\nFilename: packages/ui/client/components/views/ScreenshotError.vue:\n```\n@@ -0,0 +1,53 @@\n+<script setup lang=\"ts\">\n+defineProps<{\n+  file: string\n+  name: string\n+  url?: string\n+}>()\n+const emit = defineEmits<{ (e: 'close'): void }>()\n+\n+onKeyStroke('Escape', () => {\n+  emit('close')\n+})\n+</script>\n+\n+<template>\n+  <div w-350 max-w-screen h-full flex flex-col>\n+    <div p-4 relative border=\"base b\">\n+      <p>Screenshot error</p>\n+      <p op50 font-mono text-sm>\n+        {{ file }}\n+      </p>\n+      <p op50 font-mono text-sm>\n+        {{ name }}\n+      </p>\n+      <IconButton\n+        icon=\"i-carbon:close\"\n+        title=\"Close\"\n+        absolute\n+        top-5px\n+        right-5px\n+        text-2xl\n+        @click=\"emit('close')\"\n+      />\n+    </div>\n+\n+    <div class=\"scrolls\" grid=\"~ cols-1 rows-[min-content]\" p-4>\n+      <img\n+        v-if=\"url\"\n+        :src=\"url\"\n+        :alt=\"`Screenshot error for '${name}' test in file '${file}'`\"\n+        border=\"base t r b l dotted red-500\"\n+      >\n+      <div v-else>\n+        Something was wrong, the image cannot be resolved.\n+      </div>\n+    </div>\n+  </div>\n+</template>\n+\n+<style scoped>\n+.scrolls {\n+  place-items: center;\n+}\n+</style>\n```\n\nFilename: packages/ui/client/components/views/ViewReport.vue:\n```\n@@ -3,7 +3,7 @@\nimport type { ErrorWithDiff, File, Suite, Task } from 'vitest'\n import type Convert from 'ansi-to-html'\n import { isDark } from '~/composables/dark'\n import { createAnsiToHtmlFilter } from '~/composables/error'\n-import { config } from '~/composables/client'\n+import { browserState, config } from '~/composables/client'\n import { escapeHtml } from '~/utils/escape'\n \n const props = defineProps<{\n\n@@ -103,6 +103,30 @@\nconst failed = computed(() => {\n     ? mapLeveledTaskStacks(isDark.value, failedFlatMap)\n     : failedFlatMap\n })\n+\n+function open(task: Task) {\n+  const filePath = task.meta?.failScreenshotPath\n+  if (filePath) {\n+    fetch(`/__open-in-editor?file=${encodeURIComponent(filePath)}`)\n+  }\n+}\n+\n+const showScreenshot = ref(false)\n+const timestamp = ref(Date.now())\n+const currentTask = ref<Task | undefined>()\n+const currentScreenshotUrl = computed(() => {\n+  const file = currentTask.value?.meta.failScreenshotPath\n+  // force refresh\n+  const t = timestamp.value\n+  // browser plugin using /, change this if base can be modified\n+  return file ? `/__screenshot-error?file=${encodeURIComponent(file)}&t=${t}` : undefined\n+})\n+\n+function showScreenshotModal(task: Task) {\n+  currentTask.value = task\n+  timestamp.value = Date.now()\n+  showScreenshot.value = true\n+}\n </script>\n \n <template>\n\n@@ -121,7 +145,25 @@\nconst failed = computed(() => {\n             }rem`,\n           }\"\n         >\n-          {{ task.name }}\n+          <div flex=\"~ gap-2 items-center\">\n+            <span>{{ task.name }}</span>\n+            <template v-if=\"browserState && task.meta?.failScreenshotPath\">\n+              <IconButton\n+                v-tooltip.bottom=\"'View screenshot error'\"\n+                class=\"!op-100\"\n+                icon=\"i-carbon:image\"\n+                title=\"View screenshot error\"\n+                @click=\"showScreenshotModal(task)\"\n+              />\n+              <IconButton\n+                v-tooltip.bottom=\"'Open screenshot error in editor'\"\n+                class=\"!op-100\"\n+                icon=\"i-carbon:image-reference\"\n+                title=\"Open screenshot error in editor\"\n+                @click=\"open(task)\"\n+              />\n+            </template>\n+          </div>\n           <div\n             v-if=\"task.result?.htmlError\"\n             class=\"scrolls scrolls-rounded task-error\"\n\n@@ -146,6 +188,20 @@\nconst failed = computed(() => {\n         All tests passed in this file\n       </div>\n     </template>\n+    <template v-if=\"browserState\">\n+      <Modal v-model=\"showScreenshot\" direction=\"right\">\n+        <template v-if=\"currentTask\">\n+          <Suspense>\n+            <ScreenshotError\n+              :file=\"currentTask.file.filepath\"\n+              :name=\"currentTask.name\"\n+              :url=\"currentScreenshotUrl\"\n+              @close=\"showScreenshot = false\"\n+            />\n+          </Suspense>\n+        </template>\n+      </Modal>\n+    </template>\n   </div>\n </template>\n```"
            }
        ],
        "sw_version": "v2.0.4",
        "sw_version_wget": "https://github.com/vitest-dev/vitest/archive/refs/tags/v2.0.4.zip",
        "description": "Vitest is a testing framework powered by Vite. The `__screenshot-error` handler on the browser mode HTTP server that responds any file on the file system. Especially if the server is exposed on the network by `browser.api.host: true`, an attacker can send a request to that handler from remote to get the content of arbitrary files.This `__screenshot-error` handler on the browser mode HTTP server responds any file on the file system. This code was added by commit `2d62051`. Users explicitly exposing the browser mode server to the network by `browser.api.host: true` may get any files exposed. This issue has been addressed in versions 2.1.9 and 3.0.4. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-22",
                "value": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
            }
        ]
    },
    "CVE-2025-32014": {
        "published_date": "2025-04-07T14:56:40.413Z",
        "patch_commits": [
            {
                "url": "https://github.com/remcohaszing/estree-util-value-to-estree/commit/d0c394fbc64bc55937ffe4e162b81f15ba506e55",
                "content": "Fix __proto__ property emit\n\nThe `__proto__` property is a special use case. It can be defined as a\ncomputed property in an object expression, or via `defineProperty`. If\nit\u2019s assigned via a non-computed property in an object expression or via\na regular property assignment, even computed, this sets the prototype of\nthe object instead. This makes the generated code potentially vulnerable\nto prototype pollution.\n\nFilename: fixtures/object-proto-property-recursive/input.js:\n```\n@@ -0,0 +1,27 @@\n+// Used as input\n+// { preserveReferences: true }\n+export default ((\n+  $1 = {\n+    name: '$1'\n+  },\n+  $0 = {\n+    ['__proto__']: $1,\n+    name: '$0'\n+  }\n+) => (\n+  Object.defineProperties($1, {\n+    ['__proto__']: {\n+      value: $0,\n+      configurable: true,\n+      enumerable: true,\n+      writable: true\n+    }\n+  }),\n+  $0\n+))()\n+\n+// -------------------------------------------------------------------------------------------------\n+\n+// Default output\n+// { preserveReferences: false }\n+// Recursive references are not supported without preserveReferences\n```\n\nFilename: fixtures/object-proto-property/input.js:\n```\n@@ -0,0 +1,13 @@\n+// Used as input\n+// { preserveReferences: true }\n+export default {\n+  ['__proto__']: {}\n+}\n+\n+// -------------------------------------------------------------------------------------------------\n+\n+// Default output\n+// { preserveReferences: false }\n+const withoutPreserveReferences = {\n+  ['__proto__']: {}\n+}\n```\n\nFilename: src/estree-util-value-to-estree.ts:\n```\n@@ -326,15 +326,15 @@\nfunction symbolToEstree(symbol: symbol): Expression {\n  *   The ESTree properry node.\n  */\n function property(key: string | symbol, value: Expression): Property {\n-  const computed = typeof key !== 'string'\n+  const isString = typeof key === 'string'\n \n   return {\n     type: 'Property',\n     method: false,\n     shorthand: false,\n-    computed,\n+    computed: key === '__proto__' || !isString,\n     kind: 'init',\n-    key: computed ? symbolToEstree(key) : literal(key),\n+    key: isString ? literal(key) : symbolToEstree(key),\n     value\n   }\n }\n\n@@ -794,7 +794,15 @@\nexport function valueToEstree(value: unknown, options: Options = {}): Expression\n \n     const properties: Property[] = []\n     if (Object.getPrototypeOf(val) == null) {\n-      properties.push(property('__proto__', literal(null)))\n+      properties.push({\n+        type: 'Property',\n+        method: false,\n+        shorthand: false,\n+        computed: false,\n+        kind: 'init',\n+        key: identifier('__proto__'),\n+        value: literal(null)\n+      })\n     }\n \n     const object = val as Record<string | symbol, unknown>\n\n@@ -826,17 +834,31 @@\nexport function valueToEstree(value: unknown, options: Options = {}): Expression\n         childContext &&\n         namedContexts.indexOf(childContext) >= namedContexts.indexOf(context)\n       ) {\n-        childContext.assignment = {\n-          type: 'AssignmentExpression',\n-          operator: '=',\n-          left: {\n-            type: 'MemberExpression',\n-            computed: true,\n-            optional: false,\n-            object: identifier(context.name!),\n-            property: generate(key)\n-          },\n-          right: childContext.assignment || generate(child)\n+        if (key === '__proto__') {\n+          propertyDescriptors.push(\n+            property(key, {\n+              type: 'ObjectExpression',\n+              properties: [\n+                property('value', generate(child)),\n+                property('configurable', literal(true)),\n+                property('enumerable', literal(true)),\n+                property('writable', literal(true))\n+              ]\n+            })\n+          )\n+        } else {\n+          childContext.assignment = {\n+            type: 'AssignmentExpression',\n+            operator: '=',\n+            left: {\n+              type: 'MemberExpression',\n+              computed: true,\n+              optional: false,\n+              object: identifier(context.name!),\n+              property: generate(key)\n+            },\n+            right: childContext.assignment || generate(child)\n+          }\n         }\n       } else {\n         properties.push(property(key, generate(child)))\n```"
            }
        ],
        "sw_version": "v3.3.2",
        "sw_version_wget": "https://github.com/remcohaszing/estree-util-value-to-estree/archive/refs/tags/v3.3.2.zip",
        "description": "estree-util-value-to-estree converts a JavaScript value to an ESTree expression. When generating an ESTree from a value with a property named __proto__, valueToEstree would generate an object that specifies a prototype instead. This vulnerability is fixed in 3.3.3.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-1321",
                "value": "CWE-1321: Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')"
            }
        ]
    },
    "CVE-2025-46721": {
        "published_date": "2025-05-13T15:29:30.068Z",
        "patch_commits": [
            {
                "url": "https://github.com/justinas/nosurf/commit/ec9bb776d8e5ba9e906b6eb70428f4e7b009feee",
                "content": "Rework origin checks (#74)\n\nAddresses CVE-2025-46721.\n\nFilename: docs/origin-checks.md:\n```\n@@ -0,0 +1,83 @@\n+# Trusted origin checks in nosurf\n+\n+Before version 1.2.0, nosurf did not correctly apply trusted origin checks for non-safe HTTP requests.\n+This resulted in [CVE-2025-46721](https://www.cve.org/CVERecord?id=CVE-2025-46721).\n+\n+To alleviate this, existing checks for the `Referer` header were fixed,\n+and additional methods of checking the origin of requests were added.\n+\n+As this was technically a breaking change in nosurf, this document attempts to shed light on how origin checks function in nosurf,\n+and how users can avoid potential breakage.\n+\n+\n+<!-- vim-markdown-toc GFM -->\n+\n+* [How does nosurf check the origin?](#how-does-nosurf-check-the-origin)\n+    * [1. `Sec-Fetch-Site` header](#1-sec-fetch-site-header)\n+    * [2. `Origin` or `Referer` headers](#2-origin-or-referer-headers)\n+* [What do I need to do after upgrading to 1.2.0?](#what-do-i-need-to-do-after-upgrading-to-120)\n+* [What are the risks of not upgrading to 1.2.0?](#what-are-the-risks-of-not-upgrading-to-120)\n+\n+<!-- vim-markdown-toc -->\n+\n+## How does nosurf check the origin?\n+\n+### 1. `Sec-Fetch-Site` header\n+\n+[`Sec-Fetch-Site`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Sec-Fetch-Site) is a request header\n+sent by [all modern browsers](https://caniuse.com/mdn-http_headers_sec-fetch-site).\n+If the incoming request contains a `Sec-Fetch-Site` header with the value `same-origin`,\n+nosurf lets the request through (subject to further verification of the CSRF token).\n+\n+### 2. `Origin` or `Referer` headers\n+\n+If the `Sec-Fetch-Site` header is not present on the incoming request, or has a value other than `same-origin`,\n+nosurf must directly compare the website's origin against the origin the request was made from.\n+\n+Web content's [origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) consists of\n+a *scheme* (usually `http` or `https`), followed by the host (e.g. `example.com`), optionally followed by a port\n+(if a non-standard HTTP/HTTPS port is used).\n+This raises a problem for nosurf: because TLS may be terminated before it reaches the Go application\n+(e.g. by a load balancer or a reverse proxy),\n+in the general case nosurf can not tell whether the website is being served over HTTPS.\n+However, that information is mandatory in order to know the full \"self\" origin of the website.\n+\n+By default, nosurf will assume that the website is using HTTPS.\n+This avoids breakage in most production scenarios, but (in conjunction with `Sec-Fetch-Site` not being present),\n+can cause errors in local development scenarios.\n+To this end, nosurf provides a [`SetIsTLSFunc`](https://pkg.go.dev/github.com/justinas/nosurf#CSRFHandler.SetIsTLSFunc) method.\n+This method requires a user-supplied delegate function, a boolean value indicating whether an incoming request is considered secure.\n+\n+After constructing a full \"self\" origin from this boolean indicator and the information found in the `Host` header,\n+nosurf will compare the value of the `Origin` header on the incoming request against the self-origin.\n+If the origins are equal, request will proceed with further CSRF token checks.\n+If the origins aren't equal, nosurf will invoke the user-supplied delegate (if any) set by calling \n+[`SetIsAllowedOriginFunc`](https://pkg.go.dev/github.com/justinas/nosurf#CSRFHandler.SetIsAllowedOriginFunc).\n+If the delegate returns `false`, the request will be considered cross-origin and get aborted.\n+\n+In the unlikely case where `Origin` header does not exist,\n+nosurf will perform the same validations documented above on the `Referer` header.\n+\n+In the very unlikely case that no `Referer` header is present either, the request will be aborted.\n+\n+## What do I need to do after upgrading to 1.2.0?\n+\n+* If your website does not utilize mutating cross-origin requests, and you have no visitors using grossly outdated browsers,\n+  the check for `Sec-Fetch-Site` will be sufficient, and you do not need to make any changes to your code.\n+* If you expect your site to be visited by user with outdated browsers that do not implement the `Sec-Fetch-Site` header,\n+  but the site is served via HTTPS and you do not expect cross-origin requests, you do not need to make any changes to your code.\n+* If you are serving via plaintext HTTP (some or all of the time), when configuring nosurf, you must call `SetIsTLSFunc()`,\n+  passing it a function that correctly determines this per individual request.\n+* If you expect cross-origin requests, you must call `SetIsAllowedOriginFunc()`,\n+  passing it a function that validates whether the origin is allowed to issue non-safe requests to your website.\n+\n+## What are the risks of not upgrading to 1.2.0?\n+\n+You may be susceptible to cross-site request forgery due to [CVE-2025-46721](https://www.cve.org/CVERecord?id=CVE-2025-46721).\n+\n+However, as nosurf's CSRF token validation logic is thought to be sound,\n+all known exploits require the attacker to have control over the HTML content of a page on your website,\n+or on a page hosted on a subdomain under your website's domain (e.g. `attacker.example.com` if your website is `example.com`)\n+in order to extract or override the CSRF token set in the cookie by nosurf.\n+\n+Despite the minimal risk, I recommend that you upgrade nosurf to the latest version.\n```\n\nFilename: handler.go:\n```\n@@ -28,10 +28,14 @@\nvar safeMethods = []string{\"GET\", \"HEAD\", \"OPTIONS\", \"TRACE\"}\n // reasons for CSRF check failures\n var (\n \tErrNoReferer  = errors.New(\"A secure request contained no Referer or its value was malformed\")\n-\tErrBadReferer = errors.New(\"A secure request's Referer comes from a different Origin\" +\n+\tErrBadReferer = errors.New(\"A secure request's Referer comes from a different origin\" +\n \t\t\" from the request's URL\")\n-\tErrBadToken = errors.New(\"The CSRF token in the cookie doesn't match the one\" +\n+\tErrBadOrigin = errors.New(\"Request was made with a disallowed origin specified in the Origin header\")\n+\tErrBadToken  = errors.New(\"The CSRF token in the cookie doesn't match the one\" +\n \t\t\" received in a form/header.\")\n+\n+\t// Internal error. When this is raised, and the request is secure, we additionally check for Referer.\n+\terrNoOrigin = errors.New(\"Origin header was not present\")\n )\n \n type CSRFHandler struct {\n\n@@ -45,7 +49,9 @@\ntype CSRFHandler struct {\n \tbaseCookie http.Cookie\n \n \t// Slices of paths that are exempt from CSRF checks.\n-\t// They can be specified by...\n+\t// All of those will be matched against Request.URL.Path,\n+\t// So they should take the leading slash into account\n+\t// Paths can be specified by...\n \t// ...an exact path,\n \texemptPaths []string\n \t// ...a regexp,\n\n@@ -55,8 +61,8 @@\ntype CSRFHandler struct {\n \t// ...or a custom matcher function\n \texemptFunc func(r *http.Request) bool\n \n-\t// All of those will be matched against Request.URL.Path,\n-\t// So they should take the leading slash into account\n+\tisTLS           func(r *http.Request) bool\n+\tisAllowedOrigin func(r *url.URL) bool\n }\n \n func defaultFailureHandler(w http.ResponseWriter, r *http.Request) {\n\n@@ -95,6 +101,7 @@\nfunc New(handler http.Handler) *CSRFHandler {\n \tcsrf := &CSRFHandler{successHandler: handler,\n \t\tfailureHandler: http.HandlerFunc(defaultFailureHandler),\n \t\tbaseCookie:     baseCookie,\n+\t\tisTLS:          func(r *http.Request) bool { return true },\n \t}\n \n \treturn csrf\n\n@@ -145,26 +152,10 @@\nfunc (h *CSRFHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \n-\t// if the request is secure, we enforce origin check\n-\t// for referer to prevent MITM of http->https requests\n-\tif r.URL.Scheme == \"https\" {\n-\t\treferer, err := url.Parse(r.Header.Get(\"Referer\"))\n-\n-\t\t// if we can't parse the referer or it's empty,\n-\t\t// we assume it's not specified\n-\t\tif err != nil || referer.String() == \"\" {\n-\t\t\tctxSetReason(r, ErrNoReferer)\n-\t\t\th.handleFailure(w, r)\n-\t\t\treturn\n-\t\t}\n-\n-\t\t// if the referer doesn't share origin with the request URL,\n-\t\t// we have another error for that\n-\t\tif !sameOrigin(referer, r.URL) {\n-\t\t\tctxSetReason(r, ErrBadReferer)\n-\t\t\th.handleFailure(w, r)\n-\t\t\treturn\n-\t\t}\n+\tif err := h.ensureSameOrigin(r); err != nil {\n+\t\tctxSetReason(r, err)\n+\t\th.handleFailure(w, r)\n+\t\treturn\n \t}\n \n \t// Finally, we check the token itself.\n\n@@ -193,6 +184,75 @@\nfunc (h *CSRFHandler) handleFailure(w http.ResponseWriter, r *http.Request) {\n \th.failureHandler.ServeHTTP(w, r)\n }\n \n+func (h *CSRFHandler) ensureSameOrigin(r *http.Request) error {\n+\tselfOrigin := &url.URL{\n+\t\tScheme: \"http\",\n+\t\tHost:   r.Host,\n+\t}\n+\tisTLS := h.isTLS(r)\n+\tif isTLS {\n+\t\tselfOrigin.Scheme = \"https\"\n+\t}\n+\n+\tsecFetchSite := r.Header.Get(\"Sec-Fetch-Site\")\n+\tif secFetchSite == \"same-origin\" {\n+\t\treturn nil\n+\t}\n+\n+\t// If no `Sec-Fetch-Site: same-origin` is present, fallback to Origin or Referer,\n+\t// including considering custom allowed origins.\n+\terr := h.checkOrigin(selfOrigin, r)\n+\tif err == nil {\n+\t\treturn nil\n+\t} else if !errors.Is(err, errNoOrigin) {\n+\t\treturn err\n+\t}\n+\n+\t// If Origin header was not present, fall back on Referer check for both secure and insecure requests.\n+\t// This is opposite of Django's behavior, but should be fine, as neither of the three headers existing is an edge case.\n+\t// https://github.com/django/django/blob/8be0c0d6901669661fca578f474cd51cd284d35a/django/middleware/csrf.py#L460\n+\treturn h.checkReferer(selfOrigin, r)\n+}\n+\n+func (h *CSRFHandler) checkReferer(selfOrigin *url.URL, r *http.Request) error {\n+\treferer, err := url.Parse(r.Referer())\n+\tif err != nil || referer.String() == \"\" {\n+\t\treturn ErrNoReferer\n+\t}\n+\n+\tif sameOrigin(selfOrigin, referer) {\n+\t\treturn nil\n+\t}\n+\n+\tif h.isAllowedOrigin != nil && h.isAllowedOrigin(referer) {\n+\t\treturn nil\n+\t}\n+\n+\treturn ErrBadReferer\n+}\n+\n+func (h *CSRFHandler) checkOrigin(selfOrigin *url.URL, r *http.Request) error {\n+\toriginStr := r.Header.Get(\"Origin\")\n+\tif originStr == \"\" || originStr == \"null\" {\n+\t\treturn errNoOrigin\n+\t}\n+\n+\torigin, err := url.Parse(originStr)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif sameOrigin(selfOrigin, origin) {\n+\t\treturn nil\n+\t}\n+\n+\tif h.isAllowedOrigin != nil && h.isAllowedOrigin(origin) {\n+\t\treturn nil\n+\t}\n+\n+\treturn ErrBadOrigin\n+}\n+\n // Generates a new token, sets it on the given request and returns it\n func (h *CSRFHandler) RegenerateToken(w http.ResponseWriter, r *http.Request) string {\n \ttoken := generateToken()\n\n@@ -224,3 +284,73 @@\nfunc (h *CSRFHandler) SetFailureHandler(handler http.Handler) {\n func (h *CSRFHandler) SetBaseCookie(cookie http.Cookie) {\n \th.baseCookie = cookie\n }\n+\n+// SetIsTLSFunc sets a delegate function which determines, on a per-request basis, whether the request is made over a secure connection.\n+// This should return `true` iff the URL that the user uses to access the application begins with https://.\n+// For example, if the Go web application is served via plain-text HTTP,\n+// but the user is accessing it through HTTPS via a TLS-terminating reverse-proxy, this should return `true`.\n+//\n+// Examples:\n+//\n+// 1. If you're using the Go TLS stack (no TLS-terminating proxies in between the user and the app), you may use:\n+//\n+//\th.SetIsTLSFunc(func(r *http.Request) bool { return r.TLS != nil })\n+//\n+// 2. If your application is behind a reverse proxy that terminates TLS, you should configure the reverse proxy\n+// to report the protocol that the request was made over via an HTTP header,\n+// e.g. `X-Forwarded-Proto`.\n+// You should also validate that the request is coming in from an IP of a trusted reverse proxy\n+// to ensure that this header has not been spoofed by an attacker. For example:\n+//\n+//\tvar trustedProxies = []string{\"198.51.100.1\", \"198.51.100.2\"}\n+//\th.SetIsTLSFunc(func(r *http.Request) bool {\n+//\t\tip, _, _ := strings.Cut(r.RemoteAddr, \":\")\n+//\t\tproto := r.Header.Get(\"X-Forwarded-Proto\")\n+//\t\treturn slices.Contains(trustedProxies, ip) && proto == \"https\"\n+//\t})\n+func (h *CSRFHandler) SetIsTLSFunc(f func(*http.Request) bool) {\n+\th.isTLS = f\n+}\n+\n+// SetAllowedOrigins defines a function that checks whether the request comes from an allowed origin.\n+// This function will be invoked when the request is not considered a same-origin request.\n+// If this function returns `false`, request will be disallowed.\n+//\n+// In most cases, this will be used with [StaticOrigins].\n+func (h *CSRFHandler) SetIsAllowedOriginFunc(f func(*url.URL) bool) {\n+\th.isAllowedOrigin = f\n+}\n+\n+// StaticOrigins returns a delegate, suitable for passing to [CSRFHandler.SetIsAllowedOriginFunc],\n+// that validates the request origin against a static list of allowed origins.\n+// This function expects each element to be of form `scheme://host`, e.g.: `https://example.com`, `http://example.org`.\n+// If any element of the slice is an invalid URL, this function will return an error.\n+// If an element includes additional URL parts (e.g. a path), these parts will be ignored,\n+// as origin checks only take the scheme and host into account.\n+//\n+// Example:\n+//\n+//\th := nosurf.New()\n+//\torigins, err := nosurf.StaticOrigins(\"https://api.example.com\", \"http://insecure.example.com\")\n+//\tif err != nil {\n+//\t\tpanic(err)\n+//\t}\n+//\th.SetIsAllowedOriginFunc(origins)\n+func StaticOrigins(origins ...string) (func(r *url.URL) bool, error) {\n+\tvar allowedOrigins []*url.URL\n+\tfor _, o := range origins {\n+\t\turl, err := url.Parse(o)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tallowedOrigins = append(allowedOrigins, url)\n+\t}\n+\treturn func(u *url.URL) bool {\n+\t\tfor _, candidate := range allowedOrigins {\n+\t\t\tif sameOrigin(candidate, u) {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t\treturn false\n+\t}, nil\n+}\n```\n\nFilename: handler_test.go:\n```\n@@ -151,42 +151,209 @@\nfunc TestContextIsAccessible(t *testing.T) {\n \thand.ServeHTTP(writer, req)\n }\n \n-func TestEmptyRefererFails(t *testing.T) {\n-\thand := New(http.HandlerFunc(succHand))\n-\tfhand := correctReason(t, ErrNoReferer)\n-\thand.SetFailureHandler(fhand)\n-\n-\treq, err := http.NewRequest(\"POST\", \"https://dummy.us/\", strings.NewReader(\"a=b\"))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\twriter := httptest.NewRecorder()\n-\n-\thand.ServeHTTP(writer, req)\n-\n-\tif writer.Code != FailureCode {\n-\t\tt.Errorf(\"A POST request with no Referer should have failed with the code %d, but it didn't.\",\n-\t\t\twriter.Code)\n-\t}\n-}\n+func TestRefererHandling(t *testing.T) {\n+\tconst host = \"example.com\"\n+\tvar allowedOrigins = []string{\"https://api.example.com\", \"http://example.org\"}\n+\ttestCases := []struct {\n+\t\tname         string\n+\t\tisTLS        bool\n+\t\treferer      string\n+\t\torigin       string\n+\t\tsecFetchSite string\n+\t\texpectReason error\n+\t}{\n+\t\t{\n+\t\t\tname:         \"no Referer nor Origin fails on secure requests\",\n+\t\t\tisTLS:        true,\n+\t\t\texpectReason: ErrNoReferer,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"identical secure Referer passes\",\n+\t\t\tisTLS:        true,\n+\t\t\treferer:      \"https://example.com\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"differing Referer fails when Origin is absent\",\n+\t\t\tisTLS:        true,\n+\t\t\treferer:      \"https://attacker.lol\",\n+\t\t\texpectReason: ErrBadReferer,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"mismatched Referer scheme fails when Origin is absent\",\n+\t\t\tisTLS:        true,\n+\t\t\treferer:      \"http://example.com\",\n+\t\t\texpectReason: ErrBadReferer,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"mismatched Referer fails on insecure requests\",\n+\t\t\tisTLS:        false,\n+\t\t\treferer:      \"https://attacker.lol\",\n+\t\t\texpectReason: ErrBadReferer,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"mismatched Origin fails on insecure requests\",\n+\t\t\tisTLS:        false,\n+\t\t\torigin:       \"http://attacker.lol\",\n+\t\t\texpectReason: ErrBadOrigin,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"mismatched Origin fails on secure requests\",\n+\t\t\tisTLS:        false,\n+\t\t\torigin:       \"http://attacker.lol\",\n+\t\t\treferer:      \"https://example.com\",\n+\t\t\texpectReason: ErrBadOrigin,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"mismatched Origin scheme fails on insecure requests\",\n+\t\t\tisTLS:        false,\n+\t\t\torigin:       \"https://example.com\",\n+\t\t\texpectReason: ErrBadOrigin,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"mismatched Origin scheme fails on insecure requests\",\n+\t\t\tisTLS:        true,\n+\t\t\torigin:       \"http://example.com\",\n+\t\t\texpectReason: ErrBadOrigin,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"matching Origin passes on insecure requests\",\n+\t\t\tisTLS:        false,\n+\t\t\torigin:       \"http://example.com\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"matching Origin passes on secure requests\",\n+\t\t\tisTLS:        true,\n+\t\t\torigin:       \"https://example.com\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"explicitly allowed insecure Origin passes\",\n+\t\t\tisTLS:        false,\n+\t\t\torigin:       \"http://example.org\",\n+\t\t\treferer:      \"http://attacker.lol\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"explicitly allowed insecure Origin passes, despite a secure request\",\n+\t\t\tisTLS:        false,\n+\t\t\torigin:       \"http://example.org\",\n+\t\t\treferer:      \"http://attacker.lol\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"explicitly allowed secure Origin passes\",\n+\t\t\tisTLS:        true,\n+\t\t\torigin:       \"https://api.example.com\",\n+\t\t\treferer:      \"http://attacker.lol\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"explicitly allowed insecure Origin passes, despite an insecure request\",\n+\t\t\tisTLS:        false,\n+\t\t\torigin:       \"https://api.example.com\",\n+\t\t\treferer:      \"http://attacker.lol\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"explicitly allowed Referer passes when Origin is absent\",\n+\t\t\tisTLS:        true,\n+\t\t\treferer:      \"http://example.org\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"Sec-Fetch-Site: same-origin is sufficient\",\n+\t\t\tisTLS:        true,\n+\t\t\tsecFetchSite: \"same-origin\",\n+\t\t\texpectReason: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"Sec-Fetch-Site: same-site does not pass\",\n+\t\t\tisTLS:        true,\n+\t\t\tsecFetchSite: \"same-site\",\n+\t\t\texpectReason: ErrNoReferer,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"Sec-Fetch-Site: none does not pass\",\n+\t\t\tisTLS:        true,\n+\t\t\tsecFetchSite: \"null\",\n+\t\t\texpectReason: ErrNoReferer,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"no origin headers present, secure request does not pass\",\n+\t\t\tisTLS:        true,\n+\t\t\texpectReason: ErrNoReferer,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"no origin headers present, insecure request does not pass\",\n+\t\t\tisTLS:        false,\n+\t\t\texpectReason: ErrNoReferer,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\thand := New(http.HandlerFunc(succHand))\n+\t\t\tfhand := correctReason(t, tc.expectReason)\n+\t\t\thand.SetFailureHandler(fhand)\n+\t\t\thand.SetIsTLSFunc(func(_ *http.Request) bool { return tc.isTLS })\n+\t\t\torigins, err := StaticOrigins(allowedOrigins...)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\thand.SetIsAllowedOriginFunc(origins)\n \n-func TestDifferentOriginRefererFails(t *testing.T) {\n-\thand := New(http.HandlerFunc(succHand))\n-\tfhand := correctReason(t, ErrBadReferer)\n-\thand.SetFailureHandler(fhand)\n+\t\t\tserver := httptest.NewServer(hand)\n+\t\t\tt.Cleanup(func() { server.Close() })\n \n-\treq, err := http.NewRequest(\"POST\", \"https://dummy.us/\", strings.NewReader(\"a=b\"))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\treq.Header.Set(\"Referer\", \"http://attack-on-golang.com\")\n-\twriter := httptest.NewRecorder()\n+\t\t\t// Issue a GET to fetch the token\n+\t\t\treq, err := http.NewRequest(http.MethodGet, server.URL, nil)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\treq.Host = host\n \n-\thand.ServeHTTP(writer, req)\n+\t\t\tresp, err := server.Client().Do(req)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tcookie := getRespCookie(resp, CookieName)\n+\n+\t\t\t// Issue POST to check handling\n+\t\t\tfinalToken := b64encode(maskToken(b64decode(cookie.Value)))\n+\t\t\treq, err = http.NewRequest(\"POST\", server.URL, formBodyR([][]string{\n+\t\t\t\t{\"name\", \"Jolene\"},\n+\t\t\t\t{FormFieldName, finalToken},\n+\t\t\t}))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\treq.Host = host\n+\t\t\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n+\t\t\tif tc.referer != \"\" {\n+\t\t\t\treq.Header.Set(\"Referer\", tc.referer)\n+\t\t\t}\n+\t\t\tif tc.origin != \"\" {\n+\t\t\t\treq.Header.Set(\"Origin\", tc.origin)\n+\t\t\t}\n+\t\t\tif tc.secFetchSite != \"\" {\n+\t\t\t\treq.Header.Set(\"Sec-Fetch-Site\", tc.secFetchSite)\n+\t\t\t}\n+\t\t\treq.AddCookie(cookie)\n+\t\t\tresp, err = server.Client().Do(req)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n \n-\tif writer.Code != FailureCode {\n-\t\tt.Errorf(\"A POST request with a Referer from a different origin\"+\n-\t\t\t\"should have failed with the code %d, but it didn't.\", writer.Code)\n+\t\t\tif tc.expectReason == nil {\n+\t\t\t\tif resp.StatusCode != http.StatusOK {\n+\t\t\t\t\tt.Errorf(\"Expected request to succeed, but it failed with code %d\", resp.StatusCode)\n+\t\t\t\t}\n+\t\t\t} else if resp.StatusCode != FailureCode {\n+\t\t\t\tt.Errorf(\"Expected request to fail with status code %d, but the status code was %d\", FailureCode, resp.StatusCode)\n+\t\t\t}\n+\t\t})\n \t}\n }\n\n@@ -199,10 +366,12 @@\nfunc TestNoTokenFails(t *testing.T) {\n \t\t{\"name\", \"Jolene\"},\n \t}\n \n-\treq, err := http.NewRequest(\"POST\", \"http://dummy.us\", formBodyR(vals))\n+\treq, err := http.NewRequest(\"POST\", \"/\", formBodyR(vals))\n \tif err != nil {\n \t\tpanic(err)\n \t}\n+\treq.Host = \"example.com\"\n+\treq.Header.Add(\"Referer\", \"https://example.com\")\n \twriter := httptest.NewRecorder()\n \n \thand.ServeHTTP(writer, req)\n\n@@ -231,10 +400,12 @@\nfunc TestWrongTokenFails(t *testing.T) {\n \t\t{FormFieldName, \"$#%^&\"},\n \t}\n \n-\treq, err := http.NewRequest(\"POST\", \"http://dummy.us\", formBodyR(vals))\n+\treq, err := http.NewRequest(\"POST\", \"/\", formBodyR(vals))\n \tif err != nil {\n \t\tpanic(err)\n \t}\n+\treq.Host = \"example.com\"\n+\treq.Header.Add(\"Referer\", \"https://example.com\")\n \twriter := httptest.NewRecorder()\n \n \thand.ServeHTTP(writer, req)\n\n@@ -306,26 +477,26 @@\nfunc TestCorrectTokenPasses(t *testing.T) {\n \t}\n \n \t// Test usual POST\n-\t/*\n-\t\t{\n-\t\t\treq, err := http.NewRequest(\"POST\", server.URL, formBodyR(vals))\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n-\t\t\treq.AddCookie(cookie)\n+\t{\n+\t\treq, err := http.NewRequest(\"POST\", server.URL, formBodyR(vals))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treq.Host = \"example.com\"\n+\t\treq.Header.Add(\"Referer\", \"https://example.com\")\n+\t\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n+\t\treq.AddCookie(cookie)\n \n-\t\t\tresp, err = http.DefaultClient.Do(req)\n+\t\tresp, err = http.DefaultClient.Do(req)\n \n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tif resp.StatusCode != 200 {\n-\t\t\t\tt.Errorf(\"The request should have succeeded, but it didn't. Instead, the code was %d\",\n-\t\t\t\t\tresp.StatusCode)\n-\t\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n \t\t}\n-\t*/\n+\t\tif resp.StatusCode != 200 {\n+\t\t\tt.Errorf(\"The request should have succeeded, but it didn't. Instead, the code was %d\",\n+\t\t\t\tresp.StatusCode)\n+\t\t}\n+\t}\n \n \t// Test multipart\n \t{\n\n@@ -357,7 +528,8 @@\nfunc TestCorrectTokenPasses(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n-\n+\t\treq.Host = \"example.com\"\n+\t\treq.Header.Add(\"Referer\", \"https://example.com\")\n \t\treq.Header.Add(\"Content-Type\", wr.FormDataContentType())\n \t\treq.AddCookie(cookie)\n\n@@ -405,6 +577,8 @@\nfunc TestPrefersHeaderOverFormValue(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n+\treq.Host = \"example.com\"\n+\treq.Header.Add(\"Referer\", \"https://example.com\")\n \treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n \treq.Header.Set(HeaderName, finalToken)\n \treq.AddCookie(cookie)\n```"
            }
        ],
        "sw_version": "v1.1.1",
        "sw_version_wget": "https://github.com/justinas/nosurf/archive/refs/tags/v1.1.1.zip",
        "description": "nosurf is cross-site request forgery (CSRF) protection middleware for Go. A vulnerability in versions prior to 1.2.0 allows an attacker who controls content on the target site, or on a subdomain of the target site (either via XSS, or otherwise) to bypass CSRF checks and issue requests on user's behalf. Due to misuse of the Go `net/http` library, nosurf categorizes all incoming requests as plain-text HTTP requests, in which case the `Referer` header is not checked to have the same origin as the target webpage. If the attacker has control over HTML contents on either the target website (e.g. `example.com`), or on a website hosted on a subdomain of the target (e.g. `attacker.example.com`), they will also be able to manipulate cookies set for the target website. By acquiring the secret CSRF token from the cookie, or overriding the cookie with a new token known to the attacker, `attacker.example.com` is able to craft cross-site requests to `example.com`. A patch for the issue was released in nosurf 1.2.0. In lieu of upgrading to a patched version of nosurf, users may additionally use another HTTP middleware to ensure that a non-safe HTTP request is coming from the same origin (e.g. by requiring a `Sec-Fetch-Site: same-origin` header in the request).",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-352",
                "value": "CWE-352: Cross-Site Request Forgery (CSRF)"
            }
        ]
    },
    "CVE-2025-25304": {
        "published_date": "2025-02-14T19:28:00.388Z",
        "patch_commits": [
            {
                "url": "https://github.com/vega/vega/commit/9fb9ea07e27984394e463d286eb73944fa61411e",
                "content": "Merge pull request from GHSA-mp7w-mhcv-673j\n\nFilename: packages/vega-selections/src/selectionResolve.js:\n```\n@@ -1,6 +1,6 @@\nimport {intersection, union} from 'd3-array';\n import {array, toNumber} from 'vega-util';\n-import {$selectionId, And, Or, SelectionId, Union, VlMulti, VlPoint} from './constants';\n+import {$selectionId, And, Or, SelectionId, Union, VlMulti, VlPoint} from './util';\n \n /**\n  * Resolves selection for use as a scale domain or reads via the API.\n```\n\nFilename: packages/vega-selections/src/selectionTest.js:\n```\n@@ -1,6 +1,6 @@\nimport {bisector} from 'd3-array';\n-import {$selectionId, Intersect} from './constants';\n-import {field, inrange, isArray, isDate, toNumber} from 'vega-util';\n+import {inrange, isArray, isDate, toNumber} from 'vega-util';\n+import {$selectionId, Intersect, getter} from './util';\n \n const TYPE_ENUM = 'E',\n     TYPE_RANGE_INC = 'R',\n\n@@ -18,8 +18,7 @@\nfunction testPoint(datum, entry) {\n \n   for (; i<n; ++i) {\n     f = fields[i];\n-    f.getter = field.getter || field(f.field);\n-    dval = f.getter(datum);\n+    dval = getter(f)(datum);\n \n     if (isDate(dval)) dval = toNumber(dval);\n     if (isDate(values[i])) values[i] = toNumber(values[i]);\n```\n\nFilename: packages/vega-selections/src/selectionTuples.js:\n```\n@@ -1,5 +1,5 @@\n-import {extend, field} from 'vega-util';\n-import {$selectionId, SelectionId} from './constants';\n+import {extend} from 'vega-util';\n+import {$selectionId, SelectionId, getter} from './util';\n \n /**\n  * Maps an array of scene graph items to an array of selection tuples.\n\n@@ -11,7 +11,7 @@\nimport {$selectionId, SelectionId} from './constants';\n export function selectionTuples(array, base) {\n   return array.map(x => extend(\n     base.fields ? {\n-      values: base.fields.map(f => (f.getter || (f.getter = field(f.field)))(x.datum))\n+      values: base.fields.map(f => getter(f)(x.datum))\n     } : {\n       [SelectionId]: $selectionId(x.datum)\n     }, base));\n```\n\nFilename: packages/vega-selections/src/selectionVisitor.js:\n```\n@@ -1,6 +1,6 @@\n-import {Intersect} from './constants';\n import {Literal} from 'vega-expression';\n import {error, hasOwnProperty, peek} from 'vega-util';\n+import {Intersect} from './util';\n \n const DataPrefix = ':',\n       IndexPrefix = '@';\n```\n\nFilename: packages/vega-selections/src/util.js:\n```\n@@ -1,5 +1,16 @@\nimport {field} from 'vega-util';\n \n+// Registers vega-util field accessors to protect against XSS attacks\n+const SELECTION_GETTER = Symbol('vega_selection_getter');\n+export function getter(f) {\n+  if (!f.getter || !f.getter[SELECTION_GETTER]) {\n+    f.getter = field(f.field);\n+    f.getter[SELECTION_GETTER] = true;\n+  }\n+\n+  return f.getter;\n+}\n+\n export const Intersect = 'intersect';\n export const Union = 'union';\n export const VlMulti = 'vlMulti';\n```"
            }
        ],
        "sw_version": "v5.25.0",
        "sw_version_wget": "https://github.com/vega/vega/archive/refs/tags/v5.25.0.zip",
        "description": "Vega is a visualization grammar, a declarative format for creating, saving, and sharing interactive visualization designs. Prior to version 5.26.0 of vega and 5.4.2 of vega-selections, the `vlSelectionTuples` function can be used to call JavaScript functions, leading to cross-site scripting.`vlSelectionTuples` calls multiple functions that can be controlled by an attacker, including one call with an attacker-controlled argument. This can be used to call `Function()` with arbitrary JavaScript and the resulting function can be called with `vlSelectionTuples` or using a type coercion to call `toString` or `valueOf`. Version 5.26.0 of vega and 5.4.2 of vega-selections fix this issue.",
        "sec_adv": [],
        "cwe": [
            {
                "id": "CWE-79",
                "value": "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
            }
        ]
    }
}