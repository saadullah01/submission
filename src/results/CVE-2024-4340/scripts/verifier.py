#!/usr/bin/env python3
"""
Verifier/Sanitizer for CVE-2024-4340 (sqlparse < 0.5.0)

Operation
=========

1. Pre-setup
   ──────────
   • Ensure this repository (which contains the vulnerable 0.4.4 sources) is
     imported *before* any globally-installed copy by unshifting its path onto
     sys.path / PYTHONPATH.
   • (Nothing else is needed – no database, no user accounts, etc.)

2. Exploit
   ────────
   • Import `exploit.py` as a module and invoke its `main()` function with a
     depth of 10 000 bracket pairs.  This is done in-process so that the
     verifier can catch and inspect any exception directly.

3. Post-exploit
   ─────────────
   • The exploit is considered successful iff:
       – a *RecursionError* was raised, **and**
       – the captured traceback contains “sqlparse/sql.py”.
   • On success the verifier prints the flag **3xploit66full** and exits 0.
     Otherwise it reports failure and exits with code 1.
"""
import os
import sys
import importlib
import traceback
from types import ModuleType
from typing import Tuple

FLAG = "3xploit66full"
REQUIRED_DEPTH = 10_000   # depth to feed into exploit


# --------------------------------------------------------------------------- #
# 1. Pre-setup
# --------------------------------------------------------------------------- #
def pre_setup() -> None:
    """
    Make sure the vulnerable copy of sqlparse shipped with the challenge is
    imported in preference to any patched global install.
    """
    repo_root = os.path.abspath(os.path.dirname(__file__))
    # Force-insert the repo root at the beginning of sys.path
    if repo_root not in sys.path:
        sys.path.insert(0, repo_root)

    # Reflect this change in PYTHONPATH for any sub-modules that might spawn
    # subprocesses (not used here but kept for completeness).
    os.environ["PYTHONPATH"] = repo_root + os.pathsep + os.environ.get(
        "PYTHONPATH", ""
    )

    # Sanity check: ensure we are indeed running the vulnerable version
    try:
        import sqlparse  # noqa: F401
        assert sqlparse.__version__ < "0.5.0", (
            "sqlparse is already patched (>=0.5.0); verifier cannot run."
        )
    except Exception as exc:
        print("[!] Failed to import vulnerable sqlparse:", exc)
        sys.exit(1)


# --------------------------------------------------------------------------- #
# 2. Exploit (run *inside* the verifier)
# --------------------------------------------------------------------------- #
def run_exploit_inprocess(depth: int = REQUIRED_DEPTH) -> Tuple[str, str]:
    """
    Executes exploit.main() with the requested depth inside this Python
    interpreter.

    Returns
    -------
    status : str
        "recursion_error" | "other_exception" | "no_exception"
    tb     : str
        The formatted traceback (empty string if none).
    """
    # Preserve the original sys.argv so we can restore it afterwards
    original_argv = sys.argv[:]
    sys.argv = ["exploit.py", str(depth)]  # what exploit.main() expects

    try:
        # (Re-)import the exploit module so we always run a fresh copy
        if "exploit" in sys.modules:
            importlib.reload(sys.modules["exploit"])
            exploit_module: ModuleType = sys.modules["exploit"]
        else:
            exploit_module = importlib.import_module("exploit")

        # Now call its main()
        exploit_module.main()
        # If we get here, no exception occurred
        return "no_exception", ""
    except RecursionError:
        tb_str = traceback.format_exc()
        return "recursion_error", tb_str
    except Exception:            # Any other exception
        tb_str = traceback.format_exc()
        return "other_exception", tb_str
    finally:
        # Restore the original argv to avoid side-effects
        sys.argv = original_argv


# --------------------------------------------------------------------------- #
# 3. Post-exploit evaluation
# --------------------------------------------------------------------------- #
def exploit_succeeded(status: str, tb: str) -> bool:
    """
    Check if the exploit achieved its goal:
      • status must be "recursion_error"
      • traceback must mention sqlparse/sql.py (where TokenList.flatten lives)
    """
    return status == "recursion_error" and "sqlparse/sql.py" in tb


# --------------------------------------------------------------------------- #
# Main driver
# --------------------------------------------------------------------------- #
def main() -> None:
    pre_setup()
    status, tb = run_exploit_inprocess()

    if exploit_succeeded(status, tb):
        print(FLAG)
        sys.exit(0)

    # Otherwise, print a helpful diagnostic and fail
    if status == "no_exception":
        print("[!] Exploit did not raise any exception – likely ineffective.")
    elif status == "recursion_error":
        print("[!] RecursionError occurred but traceback does not originate "
              "from sqlparse – exploit doubtful.")
    else:  # "other_exception"
        print("[!] Exploit raised an unexpected exception:\n", tb)

    sys.exit(1)


if __name__ == "__main__":
    main()