1. Detailed Summary  
   • CVE ID: CVE-2024-4340  
   • Package: sqlparse  
   • Affected version: 0.4.4 (all versions < 0.5.0)  
   • Vulnerability type: CWE-674 Uncontrolled Recursion  
   • Severity: High (CVSS 3.1 AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)  
   • Impact: Denial of Service (parsing any user-supplied SQL with deeply nested lists causes unbounded recursion until the Python recursion limit is exceeded, crashing or hanging the host application).  

2. Root Cause Analysis  
   The core of the vulnerability resides in the `TokenList.flatten()` method (defined in `sqlparse/sql.py`), which is used internally to build string representations of grouped tokens. When grouping square brackets, `sqlparse` creates deeply nested `TokenList` instances. Upon conversion to string, each group calls its own `flatten()`, leading to an unbounded recursive descent:  

   ```python
   # sqlparse/sql.py, pre-patch flatten()
   def flatten(self):
       """Generator yielding ungrouped tokens."""
       for token in self.tokens:
           if token.is_group:
               # Recursively flatten child groups without any depth check
               yield from token.flatten()
           else:
               yield token
   ```

   Because there is no depth limit or exception handling around this recursion, passing a string with a very large number of nested brackets (e.g. '['*10000 + ']'*10000) will cause Python’s call stack to overflow, producing a `RecursionError` and effectively denying service to any caller of `sqlparse.parse()`.

   The patch adds a `try/except` around the recursive flatten calls and converts an unhandled `RecursionError` into a controlled `SQLParseError`, preventing an uncontrolled crash:

   ```diff
   --- a/sqlparse/sql.py
   +++ b/sqlparse/sql.py
   @@ -209,11 +210,14 @@
    def flatten(self):
        """Generator yielding ungrouped tokens."""
   -    for token in self.tokens:
   -        if token.is_group:
   -            yield from token.flatten()
   -        else:
   -            yield token
   +    try:
   +        for token in self.tokens:
   +            if token.is_group:
   +                yield from token.flatten()
   +            else:
   +                yield token
   +    except RecursionError as err:
   +        # Convert to a controlled parse exception rather than crash
   +        from sqlparse.exceptions import SQLParseError
   +        raise SQLParseError('Maximum recursion depth exceeded') from err
   ```

3. Exploitation Details & Proof-of-Concept  
   Any application that calls `sqlparse.parse()` (or relies on re-stringifying grouped tokens via `__str__`) on attacker-controlled input can be driven into unbounded recursion. No authentication or special privileges are required.  

   PoC (triggers `RecursionError` in sqlparse 0.4.4):  
   ```python
   import sqlparse

   # Create a SQL-like input consisting of 10 000 opening brackets followed by 10 000 closing ones.
   payload = '[' * 10000 + ']' * 10000
   # This will raise RecursionError: maximum recursion depth exceeded
   sqlparse.parse(payload)
   ```

   Sample stack trace excerpt:
   ```
   RecursionError: maximum recursion depth exceeded
   ```

   Exploit steps summary:  
   1. Attacker crafts input with deeply nested square brackets (or other groupable tokens).  
   2. Input is fed to `sqlparse.parse()` (directly or indirectly via __str__).  
   3. The parser’s grouping routines build nested `TokenList` objects.  
   4. On trying to flatten these lists for stringification, Python exceeds its recursion limit, causing an unhandled exception or hung thread—resulting in Denial of Service.  

   The patch in version 0.5.0 addresses the issue by catching `RecursionError` in `flatten()` and raising a controlled `SQLParseError`, thus preventing an uncontrolled crash. Users of versions < 0.5.0 should upgrade or implement equivalent depth checks.